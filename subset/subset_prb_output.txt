04 July 2016 08:34:28 AM

SUBSET_PRB
  C++ version
  Test the SUBSET library.

ASM_ENUM_TEST
  ASM_ENUM returns the number of alternating sign
  matrices of a given order.

   0       1
   1       1
   2       2
   3       7
   4      42
   5     429
   6    7436
   7  218348

ASM_TRIANGLE_TEST
  ASM_TRIANGLE returns a row of the alternating sign
  matrix triangle.

   0         1  
   1         1         1  
   2         2         3         2  
   3         7        14        14         7  
   4        42       105       135       105        42  
   5       429      1287      2002      2002      1287       429  
   6      7436     26026     47320     56784     47320     26026      7436  
   7    218348    873392   1813968   2519400   2519400   1813968    873392    218348  

BELL_TEST
  BELL computes Bell numbers.

  N  exact C(I)  computed C(I)

     0         1         1
     1         1         1
     2         2         2
     3         5         5
     4        15        15
     5        52        52
     6       203       203
     7       877       877
     8      4140      4140
     9     21147     21147
    10    115975    115975

CATALAN_TEST
  CATALAN computes Catalan numbers.

  N  exact C(I)  computed C(I)

     0         1         1
     1         1         1
     2         2         2
     3         5         5
     4        14        14
     5        42        42
     6       132       132
     7       429       429
     8      1430      1430
     9      4862      4862
    10     16796     16796

CATALAN_ROW_NEXT_TEST
  CATALAN_ROW_NEXT computes a row of the Catalan triangle.

  First, compute row 7:
   7         1         7        27        75       165       297       429       429  

  Now compute rows consecutively, one at a time:

   0       1  
   1       1       1  
   2       1       2       2  
   3       1       3       5       5  
   4       1       4       9      14      14  
   5       1       5      14      28      42      42  
   6       1       6      20      48      90     132     132  
   7       1       7      27      75     165     297     429     429  
   8       1       8      35     110     275     572    1001    1430    1430  
   9       1       9      44     154     429    1001    2002    3432    4862    4862  
  10       1      10      54     208     637    1638    3640    7072   11934   16796   16796  

CFRAC_TO_RAT_TEST
  CFRAC_TO_RAT continued fraction => fraction.

  Regular fraction is 4096/15625

  Continued fraction coefficients:
       1         0
       2         3
       3         1
       4         4
       5         2
       6         1
       7         1
       8        11
       9        13

  The continued fraction convergents.
  The last row contains the value of the continued
  fraction, written as a common fraction.

  I, P(I), Q(I), P(I)/Q(I)

  0       0       1               0
  1       1       3        0.333333
  2       1       4            0.25
  3       5      19        0.263158
  4      11      42        0.261905
  5      16      61        0.262295
  6      27     103        0.262136
  7     313    1194        0.262144
  8    4096   15625        0.262144

CFRAC_TO_RFRAC_TEST
  CFRAC_TO_RFRAC: continued fraction to ratio;

  Rational polynomial fraction coefficients:

  P:             1           1           2
  Q:             1           3           1           1

  Continued fraction coefficients:
         0             1
         1           0.5
         2       1.33333
         3          -0.5
         4          -1.5
         5             2

  Recovered rational polynomial:

  P:             1           1           2
  Q:             1           3           1           1

CHANGE_GREEDY_TEST
  CHANGE_GREEDY makes change using the biggest
  coins first.

  The total for which change is to be made: 73

  The available coins are:

     1
     5
    10
    25
    50
   100

  The number of coins in change is: 6

          4    2    2    0    0    0  
    73   50   10   10    1    1    1  

CHANGE_NEXT_TEST
  CHANGE_NEXT displays the next possible way to make
  change for a given total

  The total for which change is to be made: 50


  The available coins are:

     1
     5
    10
    25
    50
   100

  1
 50  

  2
 25   25  

  3
 25   10   10    5  

  4
 25   10   10    1    1    1    1    1  

  5
 25   10    5    5    5  

  6
 25   10    5    5    1    1    1    1    1  

  7
 25   10    5    1    1    1    1    1    1    1    1    1    1  

  8
 25   10    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  

  9
 25    5    5    5    5    5  

 10
 25    5    5    5    5    1    1    1    1    1  

CHINESE_CHECK_TEST
  CHINESE_CHECK checks a set of moduluses for use with the
  Chinese Remainder representation.

  Modulus set #1:
       1         1
       2         3
       3         8
       4        25
  IERROR = 0

  Modulus set #2:
       1         1
       2         3
       3        -8
       4        25
  IERROR = 1

  Modulus set #3:
       1         1
       2         3
       3         1
       4        25
  IERROR = 2

  Modulus set #4:
       1         1
       2         3
       3         8
       4        24
  IERROR = 3

CHINESE_TO_I4_TEST
  CHINESE_TO_I4 computes an integer with the given
  Chinese Remainder representation.

  The moduli:
       1         3
       2         4
       3         5
       4         7

  The number being analyzed is 37

  The remainders:
       1         1
       2         1
       3         2
       4         2

  The reconstructed number is 37

  The remainders of the reconstructed number are:
       1         1
       2         1
       3         2
       4         2

COMB_NEXT_TEST
  COMB_NEXT produces combinations.

  Combinations of size K = 1

     1
     2
     3
     4
     5

  Combinations of size K = 2

     1     2
     1     3
     1     4
     1     5
     2     3
     2     4
     2     5
     3     4
     3     5
     4     5

  Combinations of size K = 3

     1     2     3
     1     2     4
     1     2     5
     1     3     4
     1     3     5
     1     4     5
     2     3     4
     2     3     5
     2     4     5
     3     4     5

  Combinations of size K = 4

     1     2     3     4
     1     2     3     5
     1     2     4     5
     1     3     4     5
     2     3     4     5

  Combinations of size K = 5

     1     2     3     4     5

COMB_ROW_NEXT_TEST
  COMB_ROW_NEXT computes the next row of the Pascal triangle.

   0      1
   1      1    1
   2      1    2    1
   3      1    3    3    1
   4      1    4    6    4    1
   5      1    5   10   10    5    1
   6      1    6   15   20   15    6    1
   7      1    7   21   35   35   21    7    1
   8      1    8   28   56   70   56   28    8    1
   9      1    9   36   84  126  126   84   36    9    1
  10      1   10   45  120  210  252  210  120   45   10    1

COMB_UNRANK_TEST
  COMB_UNRANK returns a combination of N things
  out of M, given the lexicographic rank.

  The total set size is M = 10
  The subset size is N =    5
  The number of combinations of N out of M is 252

   Rank	  Combination

    1     1     2     3     4     5  
    2     1     2     3     4     6  
    3     1     2     3     4     7  
  6     1     2     3     4    10  
  7     1     2     3     5     6  
  8     1     2     3     5     7  
  250     5     6     8     9    10  
  251     5     7     8     9    10  
  252     6     7     8     9    10  

COMP_ENUM_TEST
  COMP_ENUM counts compositions;

       1       1       1       1       1       1       1       1       1       1
       1       2       3       4       5       6       7       8       9      10
       1       3       6      10      15      21      28      36      45      55
       1       4      10      20      35      56      84     120     165     220
       1       5      15      35      70     126     210     330     495     715
       1       6      21      56     126     252     462     792    1287    2002
       1       7      28      84     210     462     924    1716    3003    5005
       1       8      36     120     330     792    1716    3432    6435   11440
       1       9      45     165     495    1287    3003    6435   12870   24310
       1      10      55     220     715    2002    5005   11440   24310   48620
       1      11      66     286    1001    3003    8008   19448   43758   92378

COMP_NEXT_TEST
  COMP_NEXT produces compositions.

  Seeking all compositions of N = 6
  using 3 parts.

       1     6     0     0  
       2     5     1     0  
       3     4     2     0  
       4     3     3     0  
       5     2     4     0  
       6     1     5     0  
       7     0     6     0  
       8     5     0     1  
       9     4     1     1  
      10     3     2     1  
      11     2     3     1  
      12     1     4     1  
      13     0     5     1  
      14     4     0     2  
      15     3     1     2  
      16     2     2     2  
      17     1     3     2  
      18     0     4     2  
      19     3     0     3  
      20     2     1     3  
      21     1     2     3  
      22     0     3     3  
      23     2     0     4  
      24     1     1     4  
      25     0     2     4  
      26     1     0     5  
      27     0     1     5  
      28     0     0     6  

COMP_NEXT_GRLEX_TEST
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_NEXT_GRLEX determines the next COMP in
  graded lexicographic (grlex) order.

  Rank:     NC       COMP
  ----:     --   ------------
     1:      0 =  0 +  0 +  0
  ----:     --   ------------
     2:      1 =  0 +  0 +  1
     3:      1 =  0 +  1 +  0
     4:      1 =  1 +  0 +  0
  ----:     --   ------------
     5:      2 =  0 +  0 +  2
     6:      2 =  0 +  1 +  1
     7:      2 =  0 +  2 +  0
     8:      2 =  1 +  0 +  1
     9:      2 =  1 +  1 +  0
    10:      2 =  2 +  0 +  0
  ----:     --   ------------
    11:      3 =  0 +  0 +  3
    12:      3 =  0 +  1 +  2
    13:      3 =  0 +  2 +  1
    14:      3 =  0 +  3 +  0
    15:      3 =  1 +  0 +  2
    16:      3 =  1 +  1 +  1
    17:      3 =  1 +  2 +  0
    18:      3 =  2 +  0 +  1
    19:      3 =  2 +  1 +  0
    20:      3 =  3 +  0 +  0
  ----:     --   ------------
    21:      4 =  0 +  0 +  4
    22:      4 =  0 +  1 +  3
    23:      4 =  0 +  2 +  2
    24:      4 =  0 +  3 +  1
    25:      4 =  0 +  4 +  0
    26:      4 =  1 +  0 +  3
    27:      4 =  1 +  1 +  2
    28:      4 =  1 +  2 +  1
    29:      4 =  1 +  3 +  0
    30:      4 =  2 +  0 +  2
    31:      4 =  2 +  1 +  1
    32:      4 =  2 +  2 +  0
    33:      4 =  3 +  0 +  1
    34:      4 =  3 +  1 +  0
    35:      4 =  4 +  0 +  0
  ----:     --   ------------
    36:      5 =  0 +  0 +  5
    37:      5 =  0 +  1 +  4
    38:      5 =  0 +  2 +  3
    39:      5 =  0 +  3 +  2
    40:      5 =  0 +  4 +  1
    41:      5 =  0 +  5 +  0
    42:      5 =  1 +  0 +  4
    43:      5 =  1 +  1 +  3
    44:      5 =  1 +  2 +  2
    45:      5 =  1 +  3 +  1
    46:      5 =  1 +  4 +  0
    47:      5 =  2 +  0 +  3
    48:      5 =  2 +  1 +  2
    49:      5 =  2 +  2 +  1
    50:      5 =  2 +  3 +  0
    51:      5 =  3 +  0 +  2
    52:      5 =  3 +  1 +  1
    53:      5 =  3 +  2 +  0
    54:      5 =  4 +  0 +  1
    55:      5 =  4 +  1 +  0
    56:      5 =  5 +  0 +  0
  ----:     --   ------------
    57:      6 =  0 +  0 +  6
    58:      6 =  0 +  1 +  5
    59:      6 =  0 +  2 +  4
    60:      6 =  0 +  3 +  3
    61:      6 =  0 +  4 +  2
    62:      6 =  0 +  5 +  1
    63:      6 =  0 +  6 +  0
    64:      6 =  1 +  0 +  5
    65:      6 =  1 +  1 +  4
    66:      6 =  1 +  2 +  3
    67:      6 =  1 +  3 +  2
    68:      6 =  1 +  4 +  1
    69:      6 =  1 +  5 +  0
    70:      6 =  2 +  0 +  4
    71:      6 =  2 +  1 +  3

COMP_RANDOM_TEST
  COMP_RANDOM produces compositions at random.

  Seeking random compositions of N = 10
  using 5 parts.

     0     4     1     0     5  
     1     4     2     0     3  
     2     0     2     6     0  
     2     2     3     0     3  
     1     3     1     5     0  

COMP_RANDOM_GRLEX_TEST
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_RANDOM_GRLEX selects a random COMP in
  graded lexicographic (grlex) order between indices RANK1 and RANK2.

    28:      4 =  1 +  2 +  1
    59:      6 =  0 +  2 +  4
    54:      5 =  4 +  0 +  1
    43:      5 =  1 +  1 +  3
    37:      5 =  0 +  1 +  4

COMP_RANK_GRLEX_TEST
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_RANK_GRLEX determines the rank of a COMP
  from its parts.

        Actual  Inferred
  Test    Rank      Rank

     1      28        28
     2      59        59
     3      54        54
     4      43        43
     5      37        37

COMP_TO_KSUB_TEST
  COMP_TO_KSUB returns the K subset corresponding to a composition.

  COMP:   0   4   1   0   5
  KSUB:   1   6   8   9
  COMP:   0   4   1   0   5

  COMP:   1   4   2   0   3
  KSUB:   2   7  10  11
  COMP:   1   4   2   0   3

  COMP:   2   0   2   6   0
  KSUB:   3   4   7  14
  COMP:   2   0   2   6   0

  COMP:   2   2   3   0   3
  KSUB:   3   6  10  11
  COMP:   2   2   3   0   3

  COMP:   1   3   1   5   0
  KSUB:   2   6   8  14
  COMP:   1   3   1   5   0

COMP_UNRANK_GRLEX_TEST
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_UNRANK_GRLEX determines the parts
  of a COMP from its rank.

  Rank: ->  NC       COMP
  ----:     --   ------------
     1:      0 =  0 +  0 +  0
  ----:     --   ------------
     2:      1 =  0 +  0 +  1
     3:      1 =  0 +  1 +  0
     4:      1 =  1 +  0 +  0
  ----:     --   ------------
     5:      2 =  0 +  0 +  2
     6:      2 =  0 +  1 +  1
     7:      2 =  0 +  2 +  0
     8:      2 =  1 +  0 +  1
     9:      2 =  1 +  1 +  0
    10:      2 =  2 +  0 +  0
  ----:     --   ------------
    11:      3 =  0 +  0 +  3
    12:      3 =  0 +  1 +  2
    13:      3 =  0 +  2 +  1
    14:      3 =  0 +  3 +  0
    15:      3 =  1 +  0 +  2
    16:      3 =  1 +  1 +  1
    17:      3 =  1 +  2 +  0
    18:      3 =  2 +  0 +  1
    19:      3 =  2 +  1 +  0
    20:      3 =  3 +  0 +  0
  ----:     --   ------------
    21:      4 =  0 +  0 +  4
    22:      4 =  0 +  1 +  3
    23:      4 =  0 +  2 +  2
    24:      4 =  0 +  3 +  1
    25:      4 =  0 +  4 +  0
    26:      4 =  1 +  0 +  3
    27:      4 =  1 +  1 +  2
    28:      4 =  1 +  2 +  1
    29:      4 =  1 +  3 +  0
    30:      4 =  2 +  0 +  2
    31:      4 =  2 +  1 +  1
    32:      4 =  2 +  2 +  0
    33:      4 =  3 +  0 +  1
    34:      4 =  3 +  1 +  0
    35:      4 =  4 +  0 +  0
  ----:     --   ------------
    36:      5 =  0 +  0 +  5
    37:      5 =  0 +  1 +  4
    38:      5 =  0 +  2 +  3
    39:      5 =  0 +  3 +  2
    40:      5 =  0 +  4 +  1
    41:      5 =  0 +  5 +  0
    42:      5 =  1 +  0 +  4
    43:      5 =  1 +  1 +  3
    44:      5 =  1 +  2 +  2
    45:      5 =  1 +  3 +  1
    46:      5 =  1 +  4 +  0
    47:      5 =  2 +  0 +  3
    48:      5 =  2 +  1 +  2
    49:      5 =  2 +  2 +  1
    50:      5 =  2 +  3 +  0
    51:      5 =  3 +  0 +  2
    52:      5 =  3 +  1 +  1
    53:      5 =  3 +  2 +  0
    54:      5 =  4 +  0 +  1
    55:      5 =  4 +  1 +  0
    56:      5 =  5 +  0 +  0
  ----:     --   ------------
    57:      6 =  0 +  0 +  6
    58:      6 =  0 +  1 +  5
    59:      6 =  0 +  2 +  4
    60:      6 =  0 +  3 +  3
    61:      6 =  0 +  4 +  2
    62:      6 =  0 +  5 +  1
    63:      6 =  0 +  6 +  0
    64:      6 =  1 +  0 +  5
    65:      6 =  1 +  1 +  4
    66:      6 =  1 +  2 +  3
    67:      6 =  1 +  3 +  2
    68:      6 =  1 +  4 +  1
    69:      6 =  1 +  5 +  0
    70:      6 =  2 +  0 +  4
    71:      6 =  2 +  1 +  3

COMPNZ_NEXT_TEST
  COMPNZ_NEXT produces compositions using nonzero parts.

  Seeking all compositions of N = 6
  using 3 nonzero parts.

     4     1     1  
     3     2     1  
     2     3     1  
     1     4     1  
     3     1     2  
     2     2     2  
     1     3     2  
     2     1     3  
     1     2     3  
     1     1     4  

COMPNZ_RANDOM_TEST
  COMPNZ_RANDOM produces compositions at random
  with only nonzero parts.

  Seeking random compositions of N = 10
  using 5 nonzero parts.

     1     4     2     1     2  
     1     3     1     4     1  
     1     1     5     1     2  
     3     3     2     1     1  
     1     2     3     2     2  

COMPNZ_TO_KSUB_TEST
  COMPNZ_TO_KSUB returns the K subset corresponding
  to a nonzero composition.

  COMPNZ:   1   4   2   1   2
  KSUB:     1   5   7   8
  COMPNZ:   1   4   2   1   2

  COMPNZ:   1   3   1   4   1
  KSUB:     1   4   5   9
  COMPNZ:   1   3   1   4   1

  COMPNZ:   1   1   5   1   2
  KSUB:     1   2   7   8
  COMPNZ:   1   1   5   1   2

  COMPNZ:   3   3   2   1   1
  KSUB:     3   6   8   9
  COMPNZ:   3   3   2   1   1

  COMPNZ:   1   2   3   2   2
  KSUB:     1   3   6   8
  COMPNZ:   1   2   3   2   2

CONGRUENCE_TEST
  CONGRUENCE solves a congruence equation:
    A * X = C mod ( B )

   I        A         B         C         X     Mod ( A*X-C,B)

   1        1027         712          -7         443           0
   2        1027        -712           7       -1155           0
   3        1027        -712          -7         443           0
   4       -1027         712           7         443           0
   5       -1027         712          -7         269           0
   6       -1027        -712           7         443           0
   7       -1027        -712          -7       -1155           0
   8           6           8          50           7           0
   9           0           0           0           0           0
  10           0           1           0           0           0
  11           0           1           1           0           0
  12           1           0           0           0           0
  13           1           0           1           1           0
  14           1           1           0           0           0
  15        1024      -15625       11529      -15629           0
  16           0           0           1  (An error occurred)
  17           0           3          11  (An error occurred)
  18           5           0          19  (An error occurred)
  19           2           4           7  (An error occurred)

COUNT_POSE_RANDOM_TEST
  COUNT_POSE_RANDOM poses a random problem for
  the game The Count is Good.

  Problem #1

    The goal = 296

    The available numbers are

   1     2     3     5     9    50  

  Problem #2

    The goal = 817

    The available numbers are

   1     2     4     6    50   100  

  Problem #3

    The goal = 605

    The available numbers are

   3     6     8    25    50    75  

  Problem #4

    The goal = 291

    The available numbers are

   1     2     7    10    25   100  

  Problem #5

    The goal = 944

    The available numbers are

   1     2     3     5     8    75  

DEBRUIJN_TEST
  DEBRUIJN computes a de Bruijn string.

  The alphabet size is M = 2
  The string length is N = 3

  21222111

  The alphabet size is M = 3
  The string length is N = 3

  212221132131232231332333111

  The alphabet size is M = 2
  The string length is N = 4

  2121122122221111

DEC_ADD_TEST
  DEC_ADD adds two decimals.


  Number of decimal places is 3

  A = 128*10^(-1)
  B = 438*10^(-2)
  C = A + B = 172*10^(-1)

DEC_DIV_TEST
  DEC_DIV divides two decimals.

  Number of decimal places is 3

  A = 523*10^(-1)
  B = 134*10^(2)
  C = A / B = 39*10^(-4)

DEC_MUL_TEST
  DEC_MUL multiplies two decimals.

  Number of decimal places is 2

  A = 14*10^(-4)
  B = 16*10^(2)
  C = A * B = 22*10^(-1)

DEC_ROUND_TEST
  DEC_ROUND rounds a decimal to a number of digits.

           -----Before-------  -----After--------
  Digits   Mantissa  Exponent  Mantissa  Exponent

     1     523      -1         5       1
     2     523      -1        52       0
     3     523      -1       523      -1
     4     523      -1       523      -1
     2    6340       2        63       4
     3    6340       2       634       3
     4    6340       2       634       3

DEC_TO_R8_TEST
  DEC_TO_R8 converts a decimal to a real number.

  The maximum number of digits allowed is 5

     R   =>  A * 10^B  =>  R2

    -5.63163  -56316      -4     -5.6316
     9.12635   91264      -4      9.1264
     6.59018   65902      -4      6.5902
     1.23391   12339      -4      1.2339
    -1.69386  -16939      -4     -1.6939
    -8.67763  -86776      -4     -8.6776
    -4.84844  -48484      -4     -4.8484
    -7.80086  -78009      -4     -7.8009
    -9.12342  -91234      -4     -9.1234
     2.67931   26793      -4      2.6793

DEC_TO_RAT_TEST
  DEC_TO_RAT decimal => fraction.

  In this test, choose the top and bottom
  of a rational at random, and compute the
  equivalent real number.

  Then convert to decimal, and the equivalent real.

  Then convert back to rational and the equivalent real.

  -0.588297 = -563/957
  -0.588297 = -588296760*10^(-9)
  -0.588297 = -14707419/25000000

  1.1726 = 659/562
  1.1726 = 1172597864*10^(-9)
  1.1726 = 146574733/125000000

  -2.52239 = -169/67
  -2.52239 = -252238805*10^(-8)
  -2.52239 = -50447761/20000000

  -4.40909 = -485/110
  -4.40909 = -440909090*10^(-8)
  -4.40909 = -44090909/10000000

  -1.44006 = -913/634
  -1.44006 = -1440063091*10^(-9)
  -1.44006 = -1440063091/1000000000

  -1.94889 = -877/450
  -1.94889 = -1948888888*10^(-9)
  -1.94889 = -243611111/125000000

  -0.260927 = -197/755
  -0.260927 = -260927152*10^(-9)
  -0.260927 = -16307947/62500000

  297.5 = 595/2
  297.5 = 2975*10^(-1)
  297.5 = 595/2

  2.26496 = 795/351
  2.26496 = 226495726*10^(-8)
  2.26496 = 113247863/50000000

  -57.9286 = -811/14
  -57.9286 = -579285714*10^(-7)
  -57.9286 = -289642857/5000000

DEC_TO_S_TEST
  DEC_TO_S prints out a decimal.

  Mantissa  Exponent  String

     523        -1  52.3
     134         2  13400
    -134         2  -13400
       0        10  0
  123456        -8  0.00123456
  123456        -7  0.0123456
  123456        -6  0.123456
  123456        -5  1.23456
  123456        -4  12.3456
  123456        -3  123.456
  123456        -2  1234.56
  123456        -1  12345.6
  123456         0  123456
  123456         1  1234560
  123456         2  12345600
  123456         3  123456000

DEC_WIDTH_TEST
  DEC_WIDTH determines the "width" of a decimal.

  Mantissa  Exponent  Width

     523        -1         4
     134         2         5
    -134         2         6
       0        10         1
  123456        -8        10
  123456        -7         9
  123456        -6         8
  123456        -5         7
  123456        -4         7
  123456        -3         7
  123456        -2         7
  123456        -1         7
  123456         0         6
  123456         1         7
  123456         2         8
  123456         3         9

DECMAT_DET_TEST
  DECMAT_DET: determinant of a decimal matrix.


  The 123/456/789 matrix:
  1    2    3  
  4    5    6  
  7    8    9  

  Determinant of the 123/456/789 matrix = 0* 10^(0)

  The Hilbert matrix:
      0.5    0.33333       0.25        0.2  
  0.33333       0.25        0.2    0.16667  
     0.25        0.2    0.16667    0.14286  
      0.2    0.16667    0.14286      0.125  

  Determinant of the Hilbert matrix = 1* 10^(-7)

  The -1,2,-1 matrix:
   2    -1     0  
  -1     2    -1  
   0    -1     2  

  Determinant of the -1,2,-1 matrix = 4* 10^(0)

DECMAT_PRINT_TEST
  DECMAT_PRINT prints a decimal matrix.

  The Hilbert matrix:
      0.5     333.33    0.00025  
  0.33333        2.5    0.00002  
     0.25    0.00002      16667  
      0.2     1666.7     1428.6  

DERANGE_ENUM_TEST
  DERANGE_ENUM counts derangements;

       N    # of derangements

         0         1
         1         0
         2         1
         3         2
         4         9
         5        44
         6       265
         7      1854
         8     14833
         9    133496
        10   1334961

DERANGE_ENUM2_TEST
  DERANGE_ENUM2 counts derangements.

       N    # of derangements

         0  1
         1  0
         2  1
         3  2
         4  9
         5  44
         6  265
         7  1854
         8  14833
         9  133496
        10  1334961

DERANGE_ENUM3_TEST
  DERANGE_ENUM3 counts derangements.

       N    # of derangements

         0  1
         1  0
         2  1
         3  2
         4  9
         5  44
         6  265
         7  1854
         8  14833
         9  133496
        10  1334961

DERANGE0_BACK_NEXT_TEST
  DERANGE0_BACK_NEXT generates derangements
  using backtracking.

   1       4     3     1     2     0  
   2       4     3     1     0     2  
   3       4     3     0     2     1  
   4       4     3     0     1     2  
   5       4     2     3     1     0  
   6       4     2     3     0     1  
   7       4     2     1     0     3  
   8       4     2     0     1     3  
   9       4     0     3     2     1  
  10       4     0     3     1     2  
  11       4     0     1     2     3  
  12       3     4     1     2     0  
  13       3     4     1     0     2  
  14       3     4     0     2     1  
  15       3     4     0     1     2  
  16       3     2     4     1     0  
  17       3     2     4     0     1  
  18       3     2     1     4     0  
  19       3     2     0     4     1  
  20       3     0     4     2     1  
  21       3     0     4     1     2  
  22       3     0     1     4     2  
  23       2     4     3     1     0  
  24       2     4     3     0     1  
  25       2     4     1     0     3  
  26       2     4     0     1     3  
  27       2     3     4     1     0  
  28       2     3     4     0     1  
  29       2     3     1     4     0  
  30       2     3     0     4     1  
  31       2     0     4     1     3  
  32       2     0     3     4     1  
  33       2     0     1     4     3  
  34       1     4     3     2     0  
  35       1     4     3     0     2  
  36       1     4     0     2     3  
  37       1     3     4     2     0  
  38       1     3     4     0     2  
  39       1     3     0     4     2  
  40       1     2     4     0     3  
  41       1     2     3     4     0  
  42       1     2     0     4     3  
  43       1     0     4     2     3  
  44       1     0     3     4     2  

DERANGE0_CHECK_TEST
  DERANGE0_CHECK checks whether a vector of N objects
  is a derangement of (0,...,N-1).

  Potential derangement:
           1           2           3           4           0
  CHECK = 1

  Potential derangement:
           1           4           2           0           3
  CHECK = 0

  Potential derangement:
           1           2           3           0           3
  CHECK = 0

  Potential derangement:
          -1           2           3           4           0
  CHECK = 0

  Potential derangement:
           0           3           8           1           2
  CHECK = 0

DERANGE0_WEED_NEXT_TEST
  DERANGE0_WEED_NEXT generates derangements
  by generating ALL permutations, and weeding out
  the ones that are not derangements.

   1:      1     0     3     4     2  
   2:      1     0     4     2     3  
   3:      1     2     0     4     3  
   4:      1     2     3     4     0  
   5:      1     2     4     0     3  
   6:      1     3     0     4     2  
   7:      1     3     4     0     2  
   8:      1     3     4     2     0  
   9:      1     4     0     2     3  
  10:      1     4     3     0     2  
  11:      1     4     3     2     0  
  12:      2     0     1     4     3  
  13:      2     0     3     4     1  
  14:      2     0     4     1     3  
  15:      2     3     0     4     1  
  16:      2     3     1     4     0  
  17:      2     3     4     0     1  
  18:      2     3     4     1     0  
  19:      2     4     0     1     3  
  20:      2     4     1     0     3  
  21:      2     4     3     0     1  
  22:      2     4     3     1     0  
  23:      3     0     1     4     2  
  24:      3     0     4     1     2  
  25:      3     0     4     2     1  
  26:      3     2     0     4     1  
  27:      3     2     1     4     0  
  28:      3     2     4     0     1  
  29:      3     2     4     1     0  
  30:      3     4     0     1     2  
  31:      3     4     0     2     1  
  32:      3     4     1     0     2  
  33:      3     4     1     2     0  
  34:      4     0     1     2     3  
  35:      4     0     3     1     2  
  36:      4     0     3     2     1  
  37:      4     2     0     1     3  
  38:      4     2     1     0     3  
  39:      4     2     3     0     1  
  40:      4     2     3     1     0  
  41:      4     3     0     1     2  
  42:      4     3     0     2     1  
  43:      4     3     1     0     2  
  44:      4     3     1     2     0  

DIGRAPH_ARC_EULER_TEST
  DIGRAPH_ARC_EULER finds an Euler circuit of a digraph.

  The arc list of the digraph:
     1       2       5
     2       1       4
     3       2       3
     4       1       2
     5       3       1
     6       5       1
     7       4       2

  The edge list of the Euler circuit:
       1         6
       2         4
       3         3
       4         5
       5         2
       6         7
       7         1

  The node list of the Euler circuit:

	 I  Edge  Node

     0       6       1
     1       4       2
     2       3       3
     3       5       1
     4       2       4
     5       7       2
     6       1       5

DIGRAPH_ARC_PRINT_TEST
  DIGRAPH_ARC_PRINT prints a digraph.

  The arc list of the digraph:
     1       2       5
     2       1       4
     3       2       3
     4       1       2
     5       3       1
     6       5       1
     7       4       2

DIOPHANTINE_TEST
  DIOPHANTINE solves a Diophantine equation:
    A * X + B * Y = C

        A         B         C         X     Y     Residual

      1027         712           7         269        -388           0
      1027         712          -7        -269         388           0
      1027        -712           7         269         388           0
      1027        -712          -7        -269        -388           0
     -1027         712           7        -269        -388           0
     -1027         712          -7         269         388           0
     -1027        -712           7        -269         388           0
     -1027        -712          -7         269        -388           0
         6           8          50           3           4           0
         0           0           0           0           0           0
         0           1           0           0           0           0
         0           1           1           0           1           0
         1           0           0           0           0           0
         1           0           1           1           0           0
         1           1           0           1          -1           0
      1024      -15625       11529          -4          -1           0
         0           0           1  (Error occurred!)
         0           3          11  (Error occurred!)
         5           0          19  (Error occurred!)
         2           4           7  (Error occurred!)

DIOPHANTINE_SOLUTION_MINIMIZE_TEST
  DIOPHANTINE_SOLUTION_MINIMIZE computes a minimal
  Euclidean norm solution of a Diophantine equation:
    A * X + B * Y = C

  Coefficients:
    A =         4096
    B =       -15625
    C =        46116
  Solution:
    X =    665499996
    Y =    174456828
  Residual R = A * X + B * Y - C:
    R =            0

  DIOPHANTINE_SOLUTION_MINIMIZE returns
  the minimized solution:
    X =           -4
    Y =           -4
  Residual R = A * X + B * Y - C:
    R =            0

  Here is the minimal positive solution:
    X =        15621
    Y =         4092
  Residual R = A * X + B * Y - C:
    R =            0

DVEC_ADD_TEST
  DVEC_ADD adds decimal vectors representing integers;

        I        J        I + J    DVEC_ADD

       -57        92        35        35
        66        12        78        78
       -17       -87      -104      -104
       -49       -78      -127      -127
       -92        27       -65       -65
       -88       -10       -98       -98
       -20        51        31        31
        60      -100       -40       -40
        80       -30        50        50
       -81       -98      -179      -179

DVEC_COMPLEMENTX_TEST
  DVEC_COMPLEMENTX returns the ten's complement
  of a (signed) decimal vector;


  I =   -57
  J =   57
-999999943
+000000057

  I =   92
  J =   -92
+000000092
-999999908

  I =   66
  J =   -66
+000000066
-999999934

  I =   12
  J =   -12
+000000012
-999999988

  I =   -17
  J =   17
-999999983
+000000017

DVEC_MUL_TEST
  DVEC_MUL multiplies decimal vectors
  representing integers;

        I        J        I * J  DVEC_MUL

      -563       913   -514019   -514019
       659       123     81057     81057
      -169      -868    146692    146692
      -485      -780    378300    378300
      -913       268   -244684   -244684
      -877      -101     88577     88577
      -197       510   -100470   -100470
       595      -997   -593215   -593215
       795      -299   -237705   -237705
      -811      -973    789103    789103

  NOW REPEAT THE TEST...

  but use too few digits to represent big products.
  This corresponds to an "overflow".
  The result here should get the final decimal
  digits correctly, though.

        I        J        I * J  DVEC_MUL

       719       682    490358     90358
      -754      -985    742690     42690
      -480       825   -396000    -96000
      -773      -297    229581     29581
       646      -466   -301036     -1036
       384       123     47232     47232
       723       -92    -66516    -66516
       824       196    161504     61504
      -622       523   -325306    -25306
      -206      -630    129780     29780

DVEC_PRINT_TEST
  DVEC_PRINT prints a (signed) decimal vector;

  The DVEC:

-0055771439876543210

DVEC_SUB_TEST
  DVEC_SUB subtracts decimal vectors representing integers;

        I        J        I - J    DVEC_SUB

       -57        92      -149      -149
        66        12        54        54
       -17       -87        70        70
       -49       -78        29        29
       -92        27      -119      -119
       -88       -10       -78       -78
       -20        51       -71       -71
        60      -100       160       160
        80       -30       110       110
       -81       -98        17        17

DVEC_TO_I4_TEST
  DVEC_TO_I4 converts a DVEC to an I4;

         I4 => DVEC => I4

   -5632   9 9 4 3 6 8   -5632

EQUIV_NEXT_TEST
  EQUIV_NEXT generates all partitions of a set.

  Rank//element:

       1   2   3   4  

   1   1   1   1   1  
   2   1   1   1   2  
   3   1   1   2   1  
   4   1   1   2   2  
   5   1   1   2   3  
   6   1   2   1   1  
   7   1   2   1   2  
   8   1   2   1   3  
   9   1   2   2   1  
  10   1   2   2   2  
  11   1   2   2   3  
  12   1   2   3   1  
  13   1   2   3   2  
  14   1   2   3   3  
  15   1   2   3   4  

EQUIV_NEXT2_TEST
  EQUIV_NEXT2 generates all partitions of a set.

  Rank//element:

       1   2   3   4  

   1   1   1   1   1  
   2   1   1   1   2  
   3   1   1   2   1  
   4   1   1   2   2  
   5   1   1   2   3  
   6   1   2   1   1  
   7   1   2   1   2  
   8   1   2   1   3  
   9   1   2   2   1  
  10   1   2   2   2  
  11   1   2   2   3  
  12   1   2   3   1  
  13   1   2   3   2  
  14   1   2   3   3  
  15   1   2   3   4  

EQUIV_PRINT_TEST
  EQUIV_PRINT prints a set partition.

  The partition:
  Set    Size  Elements
     1     1 ::    1  
     2     3 ::    2     3     4  

  The partition:
  Set    Size  Elements
     1     1 ::    4  
     2     1 ::    1  
     3     1 ::    2  
     4     1 ::    3  

  The partition:
  Set    Size  Elements
     1     2 ::    1     4  
     2     2 ::    2     3  

  The partition:
  Set    Size  Elements
     1     2 ::    1     3  
     2     1 ::    4  
     3     1 ::    2  

  The partition:
  Set    Size  Elements
     1     1 ::    3  
     2     1 ::    2  
     3     2 ::    1     4  

EQUIV_PRINT2_TEST
  EQUIV_PRINT2 prints a set partition.

  The partition:
  (0)(1,2,3)

  The partition:
  (3)(0)(1)(2)

  The partition:
  (0,3)(1,2)

  The partition:
  (0,2)(3)(1)

  The partition:
  (2)(1)(0,3)

EQUIV_RANDOM_TEST
  EQUIV_RANDOM selects a random set partition.

  The partition:
  Set    Size  Elements
     1     1 ::    1  
     2     3 ::    2     3     4  

  The partition:
  Set    Size  Elements
     1     1 ::    4  
     2     1 ::    1  
     3     1 ::    2  
     4     1 ::    3  

  The partition:
  Set    Size  Elements
     1     2 ::    1     4  
     2     2 ::    2     3  

  The partition:
  Set    Size  Elements
     1     2 ::    1     3  
     2     1 ::    4  
     3     1 ::    2  

  The partition:
  Set    Size  Elements
     1     1 ::    3  
     2     1 ::    2  
     3     2 ::    1     4  

EULER_ROW_TEST
  EULER_ROW gets rows of the Euler triangle.

      1  
      1        0  
      1        1        0  
      1        4        1        0  
      1       11       11        1        0  
      1       26       66       26        1        0  
      1       57      302      302       57        1        0  
      1      120     1191     2416     1191      120        1        0  
      1      247     4293    15619    15619     4293      247        1        0  
      1      502    14608    88234   156190    88234    14608      502        1        0  

FROBENIUS_NUMBER_ORDER2_TEST
  FROBENIUS_NUMBER_ORDER2 computes Frobenius numbers of order 2.

        C1        C1   exact F  comput F

         2         5         3         3
         3        17        31        31
         4        19        23        53
         5        13        47        47
        12        11       109       109
        99       100      9701      9701

GRAY_NEXT_TEST
  GRAY_NEXT returns the index of the single item
  to be changed in order to get the next Gray code.

   K  Switch  Gray Code

   1       0  0000
   2       1  1000
   3       2  1100
   4      -1  0100
   5       3  0110
   6       1  1110
   7      -2  1010
   8      -1  0010
   9       4  0011
  10       1  1011
  11       2  1111
  12      -1  0111
  13      -3  0101
  14       1  1101
  15      -2  1001
  16      -1  0001

GRAY_RANK_TEST
  GRAY_RANK ranks a Gray code;

    R  =                        RANK
    G  =            GRAY_UNRANK(RANK)
    R2 =  GRAY_RANK(GRAY_UNRANK(RANK))

    R    G    R2

        0          0          0
        1          1          1
        2          3          2
        3          2          3
        4          6          4
        5          7          5
        6          5          6
        7          4          7
        8         12          8
        9         13          9
       10         15         10
       11         14         11
       12         10         12
       13         11         13
       14          9         14
       15          8         15
       16         24         16
       17         25         17
       18         27         18
       19         26         19
       20         30         20
       21         31         21
       22         29         22
       23         28         23
       24         20         24

GRAY_RANK2_TEST
  GRAY_RANK2 ranks a Gray code;

    R  =                          RANK
    G  =             GRAY_UNRANK2(RANK)
    R2 =  GRAY_RANK2(GRAY_UNRANK2(RANK))

    R    G    R2

        0          0          0
        1          1          1
        2          3          2
        3          2          3
        4          6          4
        5          7          5
        6          5          6
        7          4          7
        8         12          8
        9         13          9
       10         15         10
       11         14         11
       12         10         12
       13         11         13
       14          9         14
       15          8         15
       16         24         16
       17         25         17
       18         27         18
       19         26         19
       20         30         20
       21         31         21
       22         29         22
       23         28         23
       24         20         24

GRAY_UNRANK_TEST
  GRAY_UNRANK unranks a Gray code.

    R  =                        RANK
    G  =            GRAY_UNRANK(RANK)
    R2 =  GRAY_RANK(GRAY_UNRANK(RANK))

    R    G    R2

        0          0          0
        1          1          1
        2          3          2
        3          2          3
        4          6          4
        5          7          5
        6          5          6
        7          4          7
        8         12          8
        9         13          9
       10         15         10
       11         14         11
       12         10         12
       13         11         13
       14          9         14
       15          8         15
       16         24         16
       17         25         17
       18         27         18
       19         26         19
       20         30         20
       21         31         21
       22         29         22
       23         28         23
       24         20         24

GRAY_UNRANK2_TEST
  GRAY_UNRANK2 unranks a Gray code.

    R  =                          RANK
    G  =             GRAY_UNRANK2(RANK)
    R2 =  GRAY_RANK2(GRAY_UNRANK2(RANK))

    R    G    R2

        0          0          0
        1          1          1
        2          3          2
        3          2          3
        4          6          4
        5          7          5
        6          5          6
        7          4          7
        8         12          8
        9         13          9
       10         15         10
       11         14         11
       12         10         12
       13         11         13
       14          9         14
       15          8         15
       16         24         16
       17         25         17
       18         27         18
       19         26         19
       20         30         20
       21         31         21
       22         29         22
       23         28         23
       24         20         24

I4_BCLR_TEST
  I4_BCLR sets a given bit to 0.

  Working on I4 = 101

       Pos     I4_BCLR(I4,POS)

         0           100
         1           101
         2            97
         3           101
         4           101
         5            69
         6            37
         7           101
         8           101
         9           101
        10           101
        11           101
        12           101
        13           101
        14           101
        15           101
        16           101
        17           101
        18           101
        19           101
        20           101
        21           101
        22           101
        23           101
        24           101
        25           101
        26           101
        27           101
        28           101
        29           101
        30           101
        31           101

  Working on I4 = -31

       Pos     I4_BCLR(I4,POS)

         0           -32
         1           -31
         2           -31
         3           -31
         4           -31
         5           -63
         6           -95
         7          -159
         8          -287
         9          -543
        10         -1055
        11         -2079
        12         -4127
        13         -8223
        14        -16415
        15        -32799
        16        -65567
        17       -131103
        18       -262175
        19       -524319
        20      -1048607
        21      -2097183
        22      -4194335
        23      -8388639
        24     -16777247
        25     -33554463
        26     -67108895
        27    -134217759
        28    -268435487
        29    -536870943
        30   -1073741855
        31    2147483617

I4_BSET_TEST
  I4_BSET sets a given bit to 1.

  Working on I4 = 101

       Pos     I4_BSET(I4,POS)

         0           101
         1           103
         2           101
         3           109
         4           117
         5           101
         6           101
         7           229
         8           357
         9           613
        10          1125
        11          2149
        12          4197
        13          8293
        14         16485
        15         32869
        16         65637
        17        131173
        18        262245
        19        524389
        20       1048677
        21       2097253
        22       4194405
        23       8388709
        24      16777317
        25      33554533
        26      67108965
        27     134217829
        28     268435557
        29     536871013
        30    1073741925
        31   -2147483547

  Working on I4 = -31

       Pos     I4_BSET(I4,POS)

         0           -31
         1           -29
         2           -27
         3           -23
         4           -15
         5           -31
         6           -31
         7           -31
         8           -31
         9           -31
        10           -31
        11           -31
        12           -31
        13           -31
        14           -31
        15           -31
        16           -31
        17           -31
        18           -31
        19           -31
        20           -31
        21           -31
        22           -31
        23           -31
        24           -31
        25           -31
        26           -31
        27           -31
        28           -31
        29           -31
        30           -31
        31           -31

I4_BTEST_TEST
  I4_BTEST reports whether a given bit is 0 or 1.

  Analyze the integer I4 = 101

       Pos     I4_BTEST(I4,POS)

         0  1
         1  0
         2  1
         3  0
         4  0
         5  1
         6  1
         7  0
         8  0
         9  0
        10  0
        11  0
        12  0
        13  0
        14  0
        15  0
        16  0
        17  0
        18  0
        19  0
        20  0
        21  0
        22  0
        23  0
        24  0
        25  0
        26  0
        27  0
        28  0
        29  0
        30  0
        31  0

  Analyze the integer I4 = -31

       Pos     I4_BTEST(I4,POS)

         0  1
         1  0
         2  0
         3  0
         4  0
         5  1
         6  1
         7  1
         8  1
         9  1
        10  1
        11  1
        12  1
        13  1
        14  1
        15  1
        16  1
        17  1
        18  1
        19  1
        20  1
        21  1
        22  1
        23  1
        24  1
        25  1
        26  1
        27  1
        28  1
        29  1
        30  1
        31  1

I4_CHOOSE_TEST
  I4_CHOOSE evaluates C(N,K).

       N       K     CNK

       0       0       1

       1       0       1
       1       1       1

       2       0       1
       2       1       2
       2       2       1

       3       0       1
       3       1       3
       3       2       3
       3       3       1

       4       0       1
       4       1       4
       4       2       6
       4       3       4
       4       4       1

I4_FACTOR_TEST
  I4_FACTOR factors an integer,

  The integer is 2516

  Prime representation:

  I  FACTOR(I)  POWER(I)

       1       2       2
       2      17       1
       3      37       1

I4_FALL_TEST
  I4_FALL evaluates the falling factorial function.

         M         N     Exact  I4_Fall(M,N)
         5         0         1         1
         5         1         5         5
         5         2        20        20
         5         3        60        60
         5         4       120       120
         5         5       120       120
         5         6         0         0
        50         0         1         1
        10         1        10        10
      4000         1      4000      4000
        10         2        90        90
        18         3      4896      4896
         4         4        24        24
        98         3    912576    912576
         1         7         0         0

I4_GCD_TEST
  I4_GCD computes the greatest common divisor
  of two integers.

     I     J    I4_GCD(I,J)

  -1    15     1
  12     9     3
   3     1     1
   0     2     2
  -5    10     5
  -4     7     1
   3    12     3
  11     1     1
  13     6     1
  -4     1     1
  13    13    13
  -3     1     1
   0    14    14
  -3     6     3
  12     5     1

I4_HUGE_TEST
  I4_HUGE returns a huge integer.

  I4_HUGE() = 2147483647

I4_LOG_10_TEST
  I4_LOG_10: whole part of log base 10,

     X I4_LOG_10

     0       0
     1       0
     2       0
     3       0
     9       0
    10       1
    11       1
    99       1
   100       2
   101       2
   999       2
  1000       3
  1001       3
    -1       0
    -2       0
    -3       0
    -9       0
   -10       1
   -11       1
   -99       1
  -101       2

I4_MODP_TEST
  I4_MODP factors a number
  into a multiple and a remainder.

    Number   Divisor  Multiple Remainder

         107          50           2           7
         107         -50          -2           7
        -107          50          -2          43
        -107         -50           2          43

  Repeat using C++ percent operator:

         107          50           2           7
         107         -50          -2           7
        -107          50          -2          -7
        -107         -50           2          -7

I4_MOEBIUS_TEST
  I4_MOEBIUS evaluates the Moebius function.

         N     Exact  I4_Moebius(N)
         1         1         1
         2        -1        -1
         3        -1        -1
         4         0         0
         5        -1        -1
         6         1         1
         7        -1        -1
         8         0         0
         9         0         0
        10         1         1
        11        -1        -1
        12         0         0
        13        -1        -1
        14         1         1
        15         1         1
        16         0         0
        17        -1        -1
        18         0         0
        19        -1        -1
        20         0         0

I4_PARTITION_CONJ_TEST
  I4_PARTITION_CONJ conjugates an integer partition.

  Original partition:

  14 = 1 * 2 + 1 * 5 + 3 * 1 + 1 * 4

  Conjugate partition:

  14 = 1 * 6 + 1 * 3 + 2 * 2 + 1 * 1

I4_PARTITION_COUNT_TEST
  I4_PARTITION_COUNT counts partitions of an integer.

   N     Exact     Count

   0           1           1
   1           1           1
   2           2           2
   3           3           3
   4           5           5
   5           7           7
   6          11          11
   7          15          15
   8          22          22
   9          30          30
  10          42          42
  11          56          56
  12          77          77
  13         101         101
  14         135         135
  15         176         176
  16         231         231
  17         297         297
  18         385         385
  19         490         490
  20         627         627

I4_PARTITION_COUNT2_TEST
  I4_PARTITION_COUNT2 counts partitions of an integer.

   N     Exact     Count

     0           1                   1
     1           1                   1
     2           2                   2
     3           3                   3
     4           5                   5
     5           7                   7
     6          11                  11
     7          15                  15
     8          22                  22
     9          30                  30
    10          42                  42
    11          56                  56
    12          77                  77
    13         101                 101
    14         135                 135
    15         176                 176
    16         231                 231
    17         297                 297
    18         385                 385
    19         490                 490
    20         627                 627

I4_PARTITION_NEXT_TEST
  I4_PARTITION_NEXT generates partitions of an integer.
  Here N = 7

  7 = 1 * 7
  7 = 1 * 6 + 1 * 1
  7 = 1 * 5 + 1 * 2
  7 = 1 * 5 + 2 * 1
  7 = 1 * 4 + 1 * 3
  7 = 1 * 4 + 1 * 2 + 1 * 1
  7 = 1 * 4 + 3 * 1
  7 = 2 * 3 + 1 * 1
  7 = 1 * 3 + 2 * 2
  7 = 1 * 3 + 1 * 2 + 2 * 1
  7 = 1 * 3 + 4 * 1
  7 = 3 * 2 + 1 * 1
  7 = 2 * 2 + 3 * 1
  7 = 1 * 2 + 5 * 1
  7 = 7 * 1

I4_PARTITION_NEXT2_TEST
  I4_PARTITION_NEXT2 produces partitions of an integer.

  7 = 1 * 7
  7 = 1 * 6 + 1 * 1
  7 = 1 * 5 + 1 * 2
  7 = 1 * 5 + 2 * 1
  7 = 1 * 4 + 1 * 3
  7 = 1 * 4 + 1 * 2 + 1 * 1
  7 = 1 * 4 + 3 * 1
  7 = 2 * 3 + 1 * 1
  7 = 1 * 3 + 2 * 2
  7 = 1 * 3 + 1 * 2 + 2 * 1
  7 = 1 * 3 + 4 * 1
  7 = 3 * 2 + 1 * 1
  7 = 2 * 2 + 3 * 1
  7 = 1 * 2 + 5 * 1
  7 = 7 * 1

I4_PARTITION_PRINT_TEST
  I4_PARTITION_PRINT prints an integer partition.

  14 = 1 * 2 + 1 * 5 + 3 * 1 + 1 * 4

I4_PARTITION_RANDOM_TEST
  I4_PARTITION_RANDOM generates a random partition.


  The number of partitions of N.

     N    Number of partitions

     1       1
     2       1
     3       2
     4       3
     5       5
     6       7
     7      11
     8      15

  8 = 5 * 1 + 1 * 3
  8 = 2 * 1 + 1 * 6
  8 = 4 * 1 + 2 * 2
  8 = 4 * 1 + 1 * 4
  8 = 1 * 1 + 1 * 2 + 1 * 5

I4_PARTITIONS_NEXT_TEST
  I4_PARTITIONS_NEXT produces the next
  nondecreasing partitions of an integer, and
  if necessary, increments the integer to keep on going.

   I Sum    Partition

   0   0     0 0 0
   1   1     1 0 0
   2   2     2 0 0
   3   2     1 1 0
   4   3     3 0 0
   5   3     2 1 0
   6   3     1 1 1
   7   4     4 0 0
   8   4     3 1 0
   9   4     2 2 0
  10   4     2 1 1
  11   5     5 0 0
  12   5     4 1 0
  13   5     3 2 0
  14   5     3 1 1
  15   5     2 2 1

  You can start from any legal partition.
  Here, we restart at ( 2, 1, 0 ).

   I Sum    Partition

   0   3     2 1 0
   1   3     1 1 1
   2   4     4 0 0
   3   4     3 1 0
   4   4     2 2 0
   5   4     2 1 1
   6   5     5 0 0
   7   5     4 1 0
   8   5     3 2 0
   9   5     3 1 1
  10   5     2 2 1
  11   6     6 0 0
  12   6     5 1 0
  13   6     4 2 0
  14   6     3 3 0
  15   6     4 1 1

I4_RISE_TEST
  I4_RISE evaluates the rising factorial function.

         M         N     Exact  I4_RISE(M,N)
         5         0         1         1
         5         1         5         5
         5         2        30        30
         5         3       210       210
         5         4      1680      1680
         5         5     15120     15120
         5         6    151200    151200
        50         0         1         1
        10         1        10        10
      4000         1      4000      4000
        10         2       110       110
        18         3      6840      6840
         4         4       840       840
        98         3    970200    970200
         1         7      5040      5040

I4_SQRT_TEST
  I4_SQRT computes the square root of an integer.

       N  Sqrt(N) Remainder

       -5          2          1
       -4          2          0
       -3          1          2
       -2          1          1
       -1          1          0
        0          0          0
        1          1          0
        2          1          1
        3          1          2
        4          2          0
        5          2          1
        6          2          2
        7          2          3
        8          2          4
        9          3          0
       10          3          1
       11          3          2
       12          3          3
       13          3          4
       14          3          5
       15          3          6
       16          4          0
       17          4          1
       18          4          2
       19          4          3
       20          4          4

I4_SQRT_CF_TEST
  I4_SQRT_CF computes the continued fraction form
  of the square root of an integer.

   N  Period  Whole  Repeating Part

    1      0      1  
    2      1      1      2  
    3      2      1      1      2  
    4      0      2  
    5      1      2      4  
    6      2      2      2      4  
    7      4      2      1      1      1      4  
    8      2      2      1      4  
    9      0      3  
   10      1      3      6  
   11      2      3      3      6  
   12      2      3      2      6  
   13      5      3      1      1      1      1      6  
   14      4      3      1      2      1      6  
   15      2      3      1      6  
   16      0      4  
   17      1      4      8  
   18      2      4      4      8  
   19      6      4      2      1      3      1      2      8  
   20      2      4      2      8  

I4_TO_CHINESE_TEST
  I4_TO_CHINESE computes the Chinese Remainder
  representation of an integer.

  The moduli:
       1         3
       2         4
       3         5
       4         7

  The number being analyzed is 37

  The remainders:
       1         1
       2         1
       3         2
       4         2

  The reconstructed number is 37

  The remainders of the reconstructed number are:
       1         1
       2         1
       3         2
       4         2

I4_TO_DVEC_TEST
  I4_TO_DVEC converts an I4 to a DVEC;

         I4 => DVEC => I4

   -5632   9 9 4 3 6 8   -5632

I4_TO_I4POLY_TEST
  I4_TO_I4POLY converts an integer to a polynomial
  in a given base;

       I    BASE  DEGREE  Coefficients

       1       2       0       1  
       6       2       2       0       1       1  
      23       2       4       1       1       1       0       1  
      23       3       2       2       1       2  
      23       4       2       3       1       1  
      23       5       1       3       4  
      23       6       1       5       3  
      23      23       1       0       1  
      23      24       0      23  

  Now let I4_TO_I4POLY convert I to a polynomial,
  use I4POLY_TO_I4 to evaluate it, and compare.

       I    I2

       1       1
       6       6
      23      23
      23      23
      23      23
      23      23
      23      23
      23      23
      23      23

I4_TO_VAN_DER_CORPUT_TEST
  I4_TO_VAN_DER_CORPUT computes the elements 
  of a van der Corput sequence.
  The sequence depends on the prime number used
  as a base.

Base:          2           3           5           7          11  

   1         0.5    0.333333         0.2    0.142857   0.0909091  
   2        0.25    0.666667         0.4    0.285714    0.181818  
   3        0.75    0.111111         0.6    0.428571    0.272727  
   4       0.125    0.444444         0.8    0.571429    0.363636  
   5       0.625    0.777778        0.04    0.714286    0.454545  
   6       0.375    0.222222        0.24    0.857143    0.545455  
   7       0.875    0.555556        0.44   0.0204082    0.636364  
   8      0.0625    0.888889        0.64    0.163265    0.727273  
   9      0.5625    0.037037        0.84    0.306122    0.818182  
  10      0.3125     0.37037        0.08     0.44898    0.909091  

I4MAT_01_ROWCOLSUM_TEST
  I4MAT_01_ROWCOLSUM constructs a 01 matrix with
  given row and column sums.

  The rowsum vector:
       1         3
       2         2
       3         2
       4         1
       5         1

  The columnsum vector: 
       1         2
       2         2
       3         2
       4         2
       5         1

  The rowcolsum matrix:

  Col:          1             2             3             4             5       
  Row
  ---
    1       1       0       1       0       1  
    2       1       0       0       1       0  
    3       0       1       0       1       0  
    4       0       1       0       0       0  
    5       0       0       1       0       0  

I4MAT_U1_INVERSE_TEST
  I4MAT_U1_INVERSE inverts a unit upper triangular matrix.

  The input matrix:

  Col:          1             2             3             4             5             6       
  Row
  ---
    1       1       1       0       0       0      75  
    2       0       1       0       0       0       0  
    3       0       0       1       1       0       0  
    4       0       0       0       1       0       0  
    5       0       0       0       0       1       1  
    6       0       0       0       0       0       1  

  The inverse matrix:

  Col:          1             2             3             4             5             6       
  Row
  ---
    1       1      -1       0       0       0     -75  
    2       0       1       0       0       0       0  
    3       0       0       1      -1       0       0  
    4       0       0       0       1       0       0  
    5       0       0       0       0       1      -1  
    6       0       0       0       0       0       1  

I4MAT_PERM0_TEST
  I4MAT_PERM0 reorders an integer matrix in place.
  The rows and columns use the same permutation.

  The input matrix:

  Col:          1             2             3             4             5             6             7             8             9       
  Row
  ---
    1      11      12      13      14      15      16      17      18      19  
    2      21      22      23      24      25      26      27      28      29  
    3      31      32      33      34      35      36      37      38      39  
    4      41      42      43      44      45      46      47      48      49  
    5      51      52      53      54      55      56      57      58      59  
    6      61      62      63      64      65      66      67      68      69  
    7      71      72      73      74      75      76      77      78      79  
    8      81      82      83      84      85      86      87      88      89  
    9      91      92      93      94      95      96      97      98      99  

  The row and column permutation:

     0   1   2   3   4   5   6   7   8
     1   2   8   5   6   7   4   3   0

  The permuted matrix:

  Col:          1             2             3             4             5             6             7             8             9       
  Row
  ---
    1      99      91      92      98      97      94      95      96      93  
    2      19      11      12      18      17      14      15      16      13  
    3      29      21      22      28      27      24      25      26      23  
    4      89      81      82      88      87      84      85      86      83  
    5      79      71      72      78      77      74      75      76      73  
    6      49      41      42      48      47      44      45      46      43  
    7      59      51      52      58      57      54      55      56      53  
    8      69      61      62      68      67      64      65      66      63  
    9      39      31      32      38      37      34      35      36      33  

I4MAT_2PERM0_TEST
  I4MAT_2PERM0 reorders an integer matrix in place.
  Rows and columns use different permutations.

  The input matrix:

  Col:          1             2             3             4             5             6             7       
  Row
  ---
    1      11      12      13      14      15      16      17  
    2      21      22      23      24      25      26      27  
    3      31      32      33      34      35      36      37  
    4      41      42      43      44      45      46      47  
    5      51      52      53      54      55      56      57  
    6      61      62      63      64      65      66      67  
    7      71      72      73      74      75      76      77  
    8      81      82      83      84      85      86      87  
    9      91      92      93      94      95      96      97  

  The row permutation:

     0   1   2   3   4   5   6   7   8
     1   2   8   5   6   7   4   3   0

  The column permutation:

     0   1   2   3   4   5   6
     2   3   4   5   6   0   1

  The permuted matrix:

  Col:          1             2             3             4             5             6             7       
  Row
  ---
    1      96      97      91      92      93      94      95  
    2      16      17      11      12      13      14      15  
    3      26      27      21      22      23      24      25  
    4      86      87      81      82      83      84      85  
    5      76      77      71      72      73      74      75  
    6      46      47      41      42      43      44      45  
    7      56      57      51      52      53      54      55  
    8      66      67      61      62      63      64      65  
    9      36      37      31      32      33      34      35  

I4POLY_TEST
  I4POLY converts between power sum, factorial
  and Taylor forms, and can evaluate a polynomial


  All calls have input A as follows:
       1         0
       2         0
       3         0
       4         0
       5         0
       6         1

  Option IOPT = -3

  Output array:
       1         0
       2        24
       3       -50
       4        35
       5       -10
       6         1

  Option IOPT = -2

  Output array:
       1         0
       2         1
       3        15
       4        25
       5        10
       6         1

  Option IOPT = -1
  X0 = 2
  Value = 0

  Option IOPT = 0
  X0 = 2
  Value = 32

  Option IOPT = 6
  X0 = 2

  Output array:
       1        32
       2        80
       3        80
       4        40
       5        10
       6         1

  Option IOPT = 6
  X0 = -2

  Output array:
       1       -32
       2        80
       3       -80
       4        40
       5       -10
       6         1

I4POLY_ADD_TEST
  I4POLY_ADD adds two polynomials.

  Polynomial A:
p(x) =  5 * x^5
       +4 * x^4
       +3 * x^3
       +2 * x^2
       +1 * x

  Polynomial B:
p(x) = -5 * x^5
       +8 * x^3
       +7 * x^2
       -2 * x
       +1

  Polynomial C = A+B:
p(x) =  4 * x^4
       +11 * x^3
       +9 * x^2
       -1 * x
       +1

I4POLY_CYCLO_TEST
  I4POLY_CYCLO computes cyclotomic polynomials.

  N = 0


  The cyclotomic polynomial:
p(x) =  1

  N = 1


  The cyclotomic polynomial:
p(x) =  1 * x
       -1

  N = 2


  The cyclotomic polynomial:
p(x) =  1 * x
       +1

  N = 3


  The cyclotomic polynomial:
p(x) =  1 * x^2
       +1 * x
       +1

  N = 4


  The cyclotomic polynomial:
p(x) =  1 * x^2
       +1

  N = 5


  The cyclotomic polynomial:
p(x) =  1 * x^4
       +1 * x^3
       +1 * x^2
       +1 * x
       +1

  N = 6


  The cyclotomic polynomial:
p(x) =  1 * x^2
       -1 * x
       +1

  N = 7


  The cyclotomic polynomial:
p(x) =  1 * x^6
       +1 * x^5
       +1 * x^4
       +1 * x^3
       +1 * x^2
       +1 * x
       +1

  N = 8


  The cyclotomic polynomial:
p(x) =  1 * x^4
       +1

  N = 9


  The cyclotomic polynomial:
p(x) =  1 * x^6
       +1 * x^3
       +1

  N = 10


  The cyclotomic polynomial:
p(x) =  1 * x^4
       -1 * x^3
       +1 * x^2
       -1 * x
       +1

I4POLY_DEGREE_TEST
  I4POLY_DEGREE determines the degree of an I4POLY.

  The polynomial:
p(x) =  4 * x^4
       +3 * x^3
       +1 * x

The polyomial degree = 4

I4POLY_DIF_TEST
  I4POLY_DIF computes derivatives of an I4POLY.


  The polynomial A:
p(x) =  1 * x^3
       +2 * x^2
       -5 * x
       -6

  Differentiate A 1 times.

  The derivative, B:
p(x) =  3 * x^2
       +4 * x
       -5

  The polynomial A:
p(x) =  1 * x^4
       +3 * x^3
       +2 * x^2
       +5 * x
       -2

  Differentiate A 3 times.

  The derivative, B:
p(x) =  24 * x
       +18

I4POLY_DIV_TEST
  I4POLY_DIV computes the quotient and
  remainder for polynomial division.


  The polynomial to be divided, A:
p(x) =  1 * x^3
       +2 * x^2
       -5 * x
       -6

  The divisor polynomial, B:
p(x) =  1 * x
       -2

  The quotient polynomial, Q:
p(x) =  1 * x^2
       +4 * x
       +3

  The remainder polynomial, R:
p(x) =  0

  The polynomial to be divided, A:
p(x) =  1 * x^4
       +3 * x^3
       +2 * x^2
       +5 * x
       -2

  The divisor polynomial, B:
p(x) =  1 * x^2
       +1 * x
       -3

  The quotient polynomial, Q:
p(x) =  1 * x^2
       +2 * x
       +3

  The remainder polynomial, R:
p(x) =  8 * x
       +7

I4POLY_MUL_TEST
  I4POLY_MUL multiplies two polynomials.


  The factor A:
p(x) =  1 * x
       +1

  The factor B:
p(x) = -1 * x
       +1

  The product C = A*B:
p(x) = -1 * x^2
       +1

  The factor A:
p(x) =  3 * x^2
       +2 * x
       +1

  The factor B:
p(x) = -2 * x
       +1

  The product C = A*B:
p(x) = -6 * x^3
       -1 * x^2
       +1

I4POLY_PRINT_TEST
  I4POLY_PRINT prints an I4POLY.

  The polynomial:
p(x) =  1 * x^4
       +3 * x^3
       +2 * x^2
       +5 * x
       -2

I4POLY_TO_I4_TEST
  I4POLY_TO_I4 evaluates an integer polynomial
  at a given point;

       I    BASE  DEGREE  Coefficients

       1       2       0       1  
       6       2       2       0       1       1  
      23       2       4       1       1       1       0       1  
      23       3       2       2       1       2  
      23       4       2       3       1       1  
      23       5       1       3       4  
      23       6       1       5       3  
      23      23       1       0       1  
      23      24       0      23  

  Now let I4_TO_I4POLY convert I to a polynomial,
  use I4POLY_TO_I4 to evaluate it, and compare.

       I    I2

       1       1
       6       6
      23      23
      23      23
      23      23
      23      23
      23      23
      23      23
      23      23

I4VEC_BACKTRACK_TEST
  I4VEC_BACKTRACK uses backtracking, seeking an I4VEC X of
  N values which satisfies some condition.

  In this demonstration, we have 8 integers W(I).
  We seek all subsets that sum to 53.
  X(I) is 0 or 1 if the entry is skipped or used.

   1      53:    15  22  16
   2      53:    15  14  16   8
   3      53:    22  14   9   8

  Done!

I4VEC_DESCENDS_TEST
  I4VEC_DESCENDS is true if an integer vector decreases.


  The integer array to search:
       1         1
       2         4
       3         4
       4         3
  The preceding vector is not descending.

  The integer array to search:
       1         2
       2         1
       3         2
       4         1
  The preceding vector is not descending.

  The integer array to search:
       1         1
       2         3
       3         1
       4         2
  The preceding vector is not descending.

  The integer array to search:
       1         2
       2         4
       3         4
       4         1
  The preceding vector is not descending.

  The integer array to search:
       1         4
       2         2
       3         1
       4         1
  The preceding vector is descending.

I4VEC_FRAC_TEST
  I4VEC_FRAC: K-th smallest integer vector entry.


  The integer array to search:
       1         5
       2        20
       3        17
       4        12
       5         9
       6         2
       7         6
       8         3
       9         1
      10        13

     K   K-th smallest

     1       1
     2       2
     3       3
     4       5
     5       6
     6       9
     7      12
     8      13
     9      17
    10      20

I4VEC_INDEX_TEST
  I4VEC_INDEX returns the index of the first occurrence
  of a given value in an integer vector.


  The integer array to search:
       1         3
       2        10
       3         9
       4         6
       5         5
       6         1
       7         3
       8         2
       9         1
      10         7
      11         1
      12         5
      13         5
      14         8
      15         8
      16         1
      17         9
      18         4
      19         1
      20         1

  The value searched for is 1
  The index of first occurrence is 5

I4VEC_MAXLOC_LAST_TEST
  I4VEC_MAXLOC_LAST: index of the last maximal
  entry in an integer vector.


  The integer array to search:
       1         2
       2         5
       3         5
       4         3
       5         3
       6         1
       7         2
       8         1
       9         1
      10         4
      11         1
      12         3
      13         3
      14         4
      15         4
      16         1
      17         5
      18         2
      19         1
      20         1

  Index of last maximal entry is 16

I4VEC_PAIRWISE_PRIME_TEST
  I4VEC_PAIRWISE_PRIME is true if an integer vector
  is pairwise prime.


  The array to check:
       1         1
       2         4
       3         4
       4         3
  The preceding vector is not pairwise prime.

  The array to check:
       1         2
       2         1
       3         2
       4         1
  The preceding vector is not pairwise prime.

  The array to check:
       1         1
       2         3
       3         1
       4         2
  The preceding vector is pairwise prime.

  The array to check:
       1         2
       2         4
       3         4
       4         1
  The preceding vector is not pairwise prime.

  The array to check:
       1         4
       2         2
       3         1
       4         1
  The preceding vector is not pairwise prime.

I4VEC_REVERSE_TEST
  I4VEC_REVERSE reverses an integer vector.


  The integer array:
       1         2
       2         5
       3         5
       4         3
       5         3

  The reversed integer array:
       1         3
       2         3
       3         5
       4         5
       5         2

I4VEC_SORT_BUBBLE_A_TEST
  I4VEC_SORT_BUBBLE_A ascending sorts an integer vector
  using bubble sort.


  Unsorted array:
       1        13
       2        58
       3        50
       4        34
       5        25
       6         4
       7        15
       8         6
       9         2
      10        38
      11         3
      12        27
      13        24
      14        46
      15        48
      16         0
      17        54
      18        21
      19         5
      20         0

  Sorted array:
       1         0
       2         0
       3         2
       4         3
       5         4
       6         5
       7         6
       8        13
       9        15
      10        21
      11        24
      12        25
      13        27
      14        34
      15        38
      16        46
      17        48
      18        50
      19        54
      20        58

I4VEC_SORT_HEAP_INDEX_D_TEST
  I4VEC_SORT_HEAP_INDEX_D descending index-sorts
  an integer vector using heap sort.


  Unsorted array:
       1        13
       2        58
       3        50
       4        34
       5        25
       6         4
       7        15
       8         6
       9         2
      10        38
      11         3
      12        27
      13        24
      14        46
      15        48
      16         0
      17        54
      18        21
      19         5
      20         0

     I  INDX[I]  A[INDX[I]-1]

     0       1      58
     1      16      54
     2       2      50
     3      14      48
     4      13      46
     5       9      38
     6       3      34
     7      11      27
     8       4      25
     9      12      24
    10      17      21
    11       6      15
    12       0      13
    13       7       6
    14      18       5
    15       5       4
    16      10       3
    17       8       2
    18      19       0
    19      15       0

I4VEC_TRANSPOSE_PRINT_TEST
  I4VEC_TRANSPOSE_PRINT prints an integer vector
  with 5 entries to a row, and an optional title.

  My array:  
           1           2           3           4           5
           6           7           8           9          10
          11          12

I4VEC_UNIFORM_AB_TEST
  I4VEC_UNIFORM_AB_NEW computes pseudorandom values
  in an interval [A,B].

  The lower endpoint A = -100
  The upper endpoint B = 200
  The initial seed is 123456789


  The random vector:
         0:      -35
         1:      187
         2:      149
         3:       69
         4:       25
         5:      -81
         6:      -23
         7:      -67
         8:      -87
         9:       90
        10:      -82
        11:       35
        12:       20
        13:      127
        14:      139
        15:     -100
        16:      170
        17:        5
        18:      -72
        19:      -96

INDEX_BOX_NEXT_2D_TEST
  INDEX_BOX_NEXT_2D produces IJ indices that
  lie on the surface of a box in 2D.

  The box has logical dimensions:
  5    3

   #    I   J

  1    1    1
  2    1    2
  3    1    3
  4    2    1
  5    2    3
  6    3    1
  7    3    3
  8    4    1
  9    4    3
 10    5    1
 11    5    2
 12    5    3

INDEX_BOX_NEXT_3D_TEST
  INDEX_BOX_NEXT_3D produces IJK indices that
  lie on the surface of a box.

  The box has logical dimensions:
  5    3    4

   #    I   J   K

  1    1    1    1
  2    1    1    2
  3    1    1    3
  4    1    1    4
  5    1    2    1
  6    1    2    2
  7    1    2    3
  8    1    2    4
  9    1    3    1
 10    1    3    2
 11    1    3    3
 12    1    3    4
 13    2    1    1
 14    2    1    2
 15    2    1    3
 16    2    1    4
 17    2    2    1
 18    2    2    4
 19    2    3    1
 20    2    3    2
 21    2    3    3
 22    2    3    4
 23    3    1    1
 24    3    1    2
 25    3    1    3
 26    3    1    4
 27    3    2    1
 28    3    2    4
 29    3    3    1
 30    3    3    2
 31    3    3    3
 32    3    3    4
 33    4    1    1
 34    4    1    2
 35    4    1    3
 36    4    1    4
 37    4    2    1
 38    4    2    4
 39    4    3    1
 40    4    3    2
 41    4    3    3
 42    4    3    4
 43    5    1    1
 44    5    1    2
 45    5    1    3
 46    5    1    4
 47    5    2    1
 48    5    2    2
 49    5    2    3
 50    5    2    4
 51    5    3    1
 52    5    3    2
 53    5    3    3
 54    5    3    4

INDEX_BOX2_NEXT_2D_TEST
  INDEX_BOX2_NEXT_2D produces IJ indices that
  lie on the surface of a box2 in 2D.

  The box has half-widths:
  4    3

  and has center cell:
 10   20

   #    I   J

  1    6   17
  2    6   18
  3    6   19
  4    6   20
  5    6   21
  6    6   22
  7    6   23
  8    7   17
  9    7   23
 10    8   17
 11    8   23
 12    9   17
 13    9   23
 14   10   17
 15   10   23
 16   11   17
 17   11   23
 18   12   17
 19   12   23
 20   13   17
 21   13   23
 22   14   17
 23   14   18
 24   14   19
 25   14   20
 26   14   21
 27   14   22
 28   14   23

INDEX_BOX2_NEXT_3D_TEST
  INDEX_BOX2_NEXT_3D produces IJK indices that
  lie on the surface of a box.

  The box has half widths:
  5    3    4

  and central cell:
 10   20   30

  We will only print a PORTION of the data!

   #    I   J   K

  1    5   17   26
  2    5   17   27
  3    5   17   28
  4    5   17   29
  5    5   17   30
  6    5   17   31
  7    5   17   32
  8    5   17   33
  9    5   17   34
 10    5   18   26
370   15   23   26
371   15   23   27
372   15   23   28
373   15   23   29
374   15   23   30
375   15   23   31
376   15   23   32
377   15   23   33
378   15   23   34

INDEX_NEXT0_TEST
  INDEX_NEXT0 generates all indices of an
  array of given shape, with
  lower limit 1 and given upper limit.

  Number of index entries = 3
  Coordinate maximum HI =   3

  Index arrays:

   1     1     1  
   2     1     1  
   3     1     1  
   1     2     1  
   2     2     1  
   3     2     1  
   1     3     1  
   2     3     1  
   3     3     1  
   1     1     2  
   2     1     2  
   3     1     2  
   1     2     2  
   2     2     2  
   3     2     2  
   1     3     2  
   2     3     2  
   3     3     2  
   1     1     3  
   2     1     3  
   3     1     3  
   1     2     3  
   2     2     3  
   3     2     3  
   1     3     3  
   2     3     3  
   3     3     3  

INDEX_NEXT1_TEST
  INDEX_NEXT1 generates all indices of an
  array of given shape, with
  lower limit 1 and given upper limits.

  Number of index entries = 3

  Coordinate maximum indices:
       1         4
       2         2
       3         3

  Index arrays:

   1     1     1  
   2     1     1  
   3     1     1  
   4     1     1  
   1     2     1  
   2     2     1  
   3     2     1  
   4     2     1  
   1     1     2  
   2     1     2  
   3     1     2  
   4     1     2  
   1     2     2  
   2     2     2  
   3     2     2  
   4     2     2  
   1     1     3  
   2     1     3  
   3     1     3  
   4     1     3  
   1     2     3  
   2     2     3  
   3     2     3  
   4     2     3  

INDEX_NEXT2_TEST
  INDEX_NEXT2 generates all indices of an
  array of given shape with given
  lower and upper limits.

  Number of index entries = 3

  Coordinate, Maximum Index

       1        10        11
       2        -5        -3
       3         0         1

Index arrays:

  10    -5     0  
  11    -5     0  
  10    -4     0  
  11    -4     0  
  10    -3     0  
  11    -3     0  
  10    -5     1  
  11    -5     1  
  10    -4     1  
  11    -4     1  
  10    -3     1  
  11    -3     1  

INDEX_RANK0_TEST
  INDEX_RANK0 ranks an index with
  lower limit 1 and given upper limit.

  Number of index entries = 3

  Coordinate maximum Index = 3


  The index array:
       1         3
       2         1
       3         2

  The rank of this object is 12

INDEX_RANK1_TEST
  INDEX_RANK1 ranks an index with
  lower limit 1 and given upper limits.

  Number of index entries = 3

  Coordinate, Maximum Index

         1           4
         2           2
         3           3

  The index array:
       1         4
       2         1
       3         2

  The rank of this object is 12

INDEX_RANK2_TEST
  INDEX_RANK2 ranks an index with given
  lower and upper limits.

  Number of index entries = 3

  Coordinate, Minimum index, Maximum Index

         1           1           2
         2          10          11
         3           4           6

  The index array:
       1         1
       2        11
       3         5

  The rank of this object is 7

INDEX_UNRANK0_TEST
  INDEX_UNRANK0 unranks a multi-index.

  The multi-index has dimension 3

  The upper limit is HI = 3

  Rank, Multi-Index:

  1       1       1       1  
  2       2       1       1  
  3       3       1       1  
  4       1       2       1  
  5       2       2       1  
  6       3       2       1  
  7       1       3       1  
  8       2       3       1  
  9       3       3       1  
 10       1       1       2  
 11       2       1       2  
 12       3       1       2  
 13       1       2       2  
 14       2       2       2  
 15       3       2       2  
 16       1       3       2  
 17       2       3       2  
 18       3       3       2  
 19       1       1       3  
 20       2       1       3  
 21       3       1       3  
 22       1       2       3  
 23       2       2       3  
 24       3       2       3  
 25       1       3       3  
 26       2       3       3  
 27       3       3       3  

INDEX_UNRANK1_TEST
  INDEX_UNRANK1 unranks a multi-index.

  The multi-index has dimension 3

  The upper limits:
       1         4
       2         2
       3         3

  Rank, Multi-Index:

  1       1       1       1  
  2       2       1       1  
  3       3       1       1  
  4       4       1       1  
  5       1       2       1  
  6       2       2       1  
  7       3       2       1  
  8       4       2       1  
  9       1       1       2  
 10       2       1       2  
 11       3       1       2  
 12       4       1       2  
 13       1       2       2  
 14       2       2       2  
 15       3       2       2  
 16       4       2       2  
 17       1       1       3  
 18       2       1       3  
 19       3       1       3  
 20       4       1       3  
 21       1       2       3  
 22       2       2       3  
 23       3       2       3  
 24       4       2       3  

INDEX_UNRANK2_TEST
  INDEX_UNRANK2 unranks a multi-index.

  The multi-index has dimension 3

  The lower and upper limits are:

         0           1           2
         1          10          11
         2           4           6

  Rank, Multi-Index:

  7       1      11       5  

INVERSE_MOD_N_TEST
  INVERSE_MOD_N seeks Y, the inverse of B mod N,
  so that mod ( B * Y, N ) = 1, but returns 0
  if the inverse does not exist.

     B     N     Y     Z = ( ( B * Y ) % N )

   1   2   1   1
   1   3   1   1
   2   3   2   1
   1   4   1   1
   2   4   0   0
   3   4   3   1
   1   5   1   1
   2   5   3   1
   3   5   2   1
   4   5   4   1
   1   6   1   1
   2   6   0   0
   3   6   0   0
   4   6   0   0
   5   6   5   1
   1   7   1   1
   2   7   4   1
   3   7   5   1
   4   7   2   1
   5   7   3   1
   6   7   6   1
   1   8   1   1
   2   8   0   0
   3   8   3   1
   4   8   0   0
   5   8   5   1
   6   8   0   0
   7   8   7   1
   1   9   1   1
   2   9   5   1
   3   9   0   0
   4   9   7   1
   5   9   2   1
   6   9   0   0
   7   9   4   1
   8   9   8   1
   1  10   1   1
   2  10   0   0
   3  10   7   1
   4  10   0   0
   5  10   0   0
   6  10   0   0
   7  10   3   1
   8  10   0   0
   9  10   9   1

INVERSION_TO_PERM0_TEST
  INVERSION_TO_PERM0: inversion to permutation (0,...,N-1).


  The permutation:
       1         2
       2         4
       3         0
       4         3
       5         1

  The inversion sequence:
       1         0
       2         0
       3         2
       4         1
       5         3

  The recovered permutation:
       1         2
       2         4
       3         0
       4         3
       5         1

INVOLUTE_ENUM_TEST
  INVOLUTE_ENUM counts involutions;


  N    # of involutions

         0           1
         1           1
         2           2
         3           4
         4          10
         5          26
         6          76
         7         232
         8         764
         9        2620
        10        9496

JFRAC_TO_RFRAC_TEST
  JFRAC_TO_RFRAC converts a J fraction
  to a rational polynomial fraction.

  The original rational polynomial coefficients:

      0.218418        0.956318        0.829509        0.561695        0.415307       0.0661187  
      0.641848        0.273997        0.109216         1.57976        0.153816         1.12019               1  

  The J fraction coefficients:

     0.0661187         24.0763       -0.310636         1.40276         5.16789      -0.0686133  
      -5.16104         4.91564        -0.94563        -1.04001         2.91888        0.432351  

  The recovered rational polynomial:

      0.218418        0.956318        0.829509        0.561695        0.415307       0.0661187  
      0.641848        0.273997        0.109216         1.57976        0.153816         1.12019               1  

JOSEPHUS_TEST
  JOSEPHUS solves Josephus problems.

    N    M    K	 X

   41      3     41     31
   41    -38     41     31
   41      3     40     16
   64      2     64      1
 1000      2   1000    977

KSUB_NEXT_TEST
  KSUB_NEXT generates all K subsets of an N set
  in lexicographic order.

   1       1   2   3
   2       1   2   4
   3       1   2   5
   4       1   3   4
   5       1   3   5
   6       1   4   5
   7       2   3   4
   8       2   3   5
   9       2   4   5
  10       3   4   5

KSUB_NEXT2_TEST
  KSUB_NEXT2 generates the next K subset of an
  N set by the revolving door method.

Rank  Subset  Added  Removed

   1   1   2   3      0   0
   2   1   3   4      4   2
   3   2   3   4      2   1
   4   1   2   4      1   3
   5   1   4   5      5   2
   6   2   4   5      2   1
   7   3   4   5      3   2
   8   1   3   5      1   4
   9   2   3   5      2   1
  10   1   2   5      1   3

KSUB_NEXT3_TEST
  KSUB_NEXT3 generates all K subsets of an N set
  using the revolving door method.

Rank    Subset  Added Removed

   1   1   2   3      0   0
   2   1   3   4      4   2
   3   2   3   4      2   1
   4   1   2   4      1   3
   5   1   4   5      5   2
   6   2   4   5      2   1
   7   3   4   5      3   2
   8   1   3   5      1   4
   9   2   3   5      2   1
  10   1   2   5      1   3

KSUB_NEXT4_TEST
  KSUB_NEXT4 generates K subsets of an N set.
  N = 5
  K = 3

Rank    Subset

   1       1     2     3  
   2       1     2     4  
   3       1     3     4  
   4       2     3     4  
   5       1     2     5  
   6       1     3     5  
   7       2     3     5  
   8       1     4     5  
   9       2     4     5  
  10       3     4     5  

KSUB_RANDOM_TEST
  KSUB_RANDOM generates a random K subset of an N set.
  Set size is N =    5
  Subset size is K = 3

    2    4    5
    1    2    4
    1    4    5
    1    4    5
    1    3    4

KSUB_RANDOM2_TEST
  KSUB_RANDOM2 generates a random K subset of an N set.
  Set size is N =    5
  Subset size is K = 3

    1    4    5
    1    2    3
    1    3    4
    1    4    5
    1    2    3

KSUB_RANDOM3_TEST
  KSUB_RANDOM3 generates a random K subset of an N set.
  Set size is N =    5
  Subset size is K = 3

    1    0    0    1    1
    1    1    0    1    0
    1    0    0    1    1
    1    1    1    0    0
    0    1    0    1    1
    1    1    0    1    0
    1    0    0    1    1
    1    0    1    0    1
    1    0    0    1    1
    0    1    0    1    1

KSUB_RANDOM4_TEST
  KSUB_RANDOM4 generates a random K subset of an N set.
  Set size is N =    5
  Subset size is K = 3

    1    2    4
    3    4    5
    2    3    4
    1    3    5
    1    2    5
    2    3    5
    2    3    5
    1    4    5
    1    2    5
    1    2    5

KSUB_RANDOM5_TEST
  KSUB_RANDOM5 generates a random K subset of an N set.
  Set size is N =    52
  Subset size is K = 5

   12   24   31   44   50
    4    6    8   15   35
    4   23   24   40   43
    1    5    8   20   47
    4    9   17   44   45

KSUB_RANK_TEST
  KSUB_RANK: determine the rank of a K subset of an N set.

  For N = 6
  and K = 3
  the subset is:

   1   3   5

  The computed rank is 6

KSUB_TO_COMP_TEST
  KSUB_TO_COMP returns the composition corresponding to a K subset.

  COMP:   0   4   1   0   5
  KSUB:   1   6   8   9
  COMP:   0   4   1   0   5

  COMP:   1   4   2   0   3
  KSUB:   2   7  10  11
  COMP:   1   4   2   0   3

  COMP:   2   0   2   6   0
  KSUB:   3   4   7  14
  COMP:   2   0   2   6   0

  COMP:   2   2   3   0   3
  KSUB:   3   6  10  11
  COMP:   2   2   3   0   3

  COMP:   1   3   1   5   0
  KSUB:   2   6   8  14
  COMP:   1   3   1   5   0

KSUB_TO_COMPNZ_TEST
  KSUB_TO_COMPNZ returns the nonzero composition 
  corresponding to a K subset.

  COMPNZ:   1   4   2   1   2
  KSUB:     1   5   7   8
  COMPNZ:   1   4   2   1   2

  COMPNZ:   1   3   1   4   1
  KSUB:     1   4   5   9
  COMPNZ:   1   3   1   4   1

  COMPNZ:   1   1   5   1   2
  KSUB:     1   2   7   8
  COMPNZ:   1   1   5   1   2

  COMPNZ:   3   3   2   1   1
  KSUB:     3   6   8   9
  COMPNZ:   3   3   2   1   1

  COMPNZ:   1   2   3   2   2
  KSUB:     1   3   6   8
  COMPNZ:   1   2   3   2   2

KSUB_UNRANK_TEST
  KSUB_UNRANK: find the K-subset of an N set
  of a given rank.

  For N = 5
  and K = 3
  and the desired rank is 8

  The subset of the given rank is:

   1   4   5

L4VEC_NEXT_TEST
  L4VEC_NEXT generates logical vectors in order.

  000
  001
  010
  011
  100
  101
  110
  111

MATRIX_PRODUCT_OPT_TEST
  MATRIX_PRODUCT_OPT seeks the optimal order
  for a chain of matrix products.

  Matrix ranks:

   I    R    C

    0      4      2
    1      2      3
    2      3      1
    3      1      2
    4      2      2
    5      2      3

  Optimal cost is 36

  Ordering:
       1         2
       2         1
       3         4
       4         5
       5         3

MOEBIUS_MATRIX_TEST
  MOEBIUS_MATRIX computes the Moebius matrix.

  The input matrix:

  Col:          1             2             3             4             5             6             7             8             9            10       
  Row
  ---
    1       0       0       0       0       0       1       0       0       0       1  
    2       0       0       1       1       0       0       0       0       0       0  
    3       1       0       0       0       0       0       0       0       1       0  
    4       1       0       0       0       1       0       0       0       1       0  
    5       0       0       0       0       0       1       0       0       0       0  
    6       0       0       0       0       0       0       1       0       0       0  
    7       0       0       0       0       0       0       0       0       0       0  
    8       0       1       0       0       0       0       0       0       0       0  
    9       0       0       0       0       0       1       0       0       0       1  
   10       0       0       0       0       0       0       1       0       0       0  
   11       0       0       0       0       0       0       1       0       0       0  

  Col:         11       
  Row
  ---
    1       0  
    2       0  
    3       0  
    4       0  
    5       0  
    6       0  
    7       0  
    8       0  
    9       1  
   10       0  
   11       0  

  The Moebius matrix:

  Col:          1             2             3             4             5             6             7             8             9            10       
  Row
  ---
    1       1       0       0       0       0      -1       1       0       0      -1  
    2       1       1      -1      -1       0      -1       1       0       1      -1  
    3      -1       0       1       0       0       1      -1       0      -1       1  
    4      -1       0       0       1      -1       2      -1       0      -1       1  
    5       0       0       0       0       1      -1       0       0       0       0  
    6       0       0       0       0       0       1      -1       0       0       0  
    7       0       0       0       0       0       0       1       0       0       0  
    8       0      -1       0       0       0       0       0       1       0       0  
    9       0       0       0       0       0      -1       2       0       1      -1  
   10       0       0       0       0       0       0      -1       0       0       1  
   11       0       0       0       0       0       0      -1       0       0       0  

  Col:         11       
  Row
  ---
    1       0  
    2       0  
    3       0  
    4       0  
    5       0  
    6       0  
    7       0  
    8       0  
    9      -1  
   10       0  
   11       1  

MONOMIAL_COUNT_TEST
  MONOMIAL_COUNT counts the number of monomials of
  degrees 0 through DEGREE_MAX in a space of dimension DIM.

  DIM  Count

   1        10
   2        55
   3       220
   4       715
   5      2002
   6      5005

MONOMIAL_COUNTS
  MONOMIAL_COUNTS counts the number of monomials of
  degrees 0 through DEGREE_MAX in a space of dimension DIM.

  DIM = 1

         0         1
         1         1
         2         1
         3         1
         4         1
         5         1
         6         1
         7         1
         8         1
         9         1

     Total        10

  DIM = 2

         0         1
         1         2
         2         3
         3         4
         4         5
         5         6
         6         7
         7         8
         8         9
         9        10

     Total        55

  DIM = 3

         0         1
         1         3
         2         6
         3        10
         4        15
         5        21
         6        28
         7        36
         8        45
         9        55

     Total       220

  DIM = 4

         0         1
         1         4
         2        10
         3        20
         4        35
         5        56
         6        84
         7       120
         8       165
         9       220

     Total       715

  DIM = 5

         0         1
         1         5
         2        15
         3        35
         4        70
         5       126
         6       210
         7       330
         8       495
         9       715

     Total      2002

  DIM = 6

         0         1
         1         6
         2        21
         3        56
         4       126
         5       252
         6       462
         7       792
         8      1287
         9      2002

     Total      5005

MORSE_THUE_TEST
  MORSE_THUE computes the Morse-Thue numbers.

  0110100110
  0101101001
  0110011010
  0110010110
  0110100101
  1010011001
  0110100101
  1001101001
  0110100110
  0101100110
  1

MULTINOMIAL_COEF1_TEST
  MULTINOMIAL_COEF1 computes multinomial
  coefficients using the Gamma function;

  Line 10 of the BINOMIAL table:

   0    10          1
   1     9         10
   2     8         45
   3     7        120
   4     6        210
   5     5        252
   6     4        210
   7     3        120
   8     2         45
   9     1         10
  10     0          1

  Level 5 of the TRINOMIAL coefficients:

   0     0     5          1
   0     1     4          5
   0     2     3         10
   0     3     2         10
   0     4     1          5
   0     5     0          1

   1     0     4          5
   1     1     3         20
   1     2     2         30
   1     3     1         20
   1     4     0          5

   2     0     3         10
   2     1     2         30
   2     2     1         30
   2     3     0         10

   3     0     2         10
   3     1     1         20
   3     2     0         10

   4     0     1          5
   4     1     0          5

   5     0     0          1

MULTINOMIAL_COEF2_TEST
  MULTINOMIAL_COEF2 computes multinomial
  coefficients directly.

  Line 10 of the BINOMIAL table:

   0    10          1
   1     9         10
   2     8         45
   3     7        120
   4     6        210
   5     5        252
   6     4        210
   7     3        120
   8     2         45
   9     1         10
  10     0          1

  Level 5 of the TRINOMIAL coefficients:

   0     0     5          1
   0     1     4          5
   0     2     3         10
   0     3     2         10
   0     4     1          5
   0     5     0          1

   1     0     4          5
   1     1     3         20
   1     2     2         30
   1     3     1         20
   1     4     0          5

   2     0     3         10
   2     1     2         30
   2     2     1         30
   2     3     0         10

   3     0     2         10
   3     1     1         20
   3     2     0         10

   4     0     1          5
   4     1     0          5

   5     0     0          1

MULTIPERM_ENUM_TEST
  MULTIPERM_ENUM enumerates multipermutations.

  N is the number of objects to be permuted.
  K is the number of distinct types of objects.
  COUNTS is the number of objects of each type.
  NUMBER is the number of multipermutations.

  Number       N       K       Counts(1:K)

       5       5       2     4     1
      20       5       3     1     1     3
      60       5       4     1     1     2     1
       5       5       2     1     4
     120       5       5     1     1     1     1     1

MULTIPERM_NEXT_TEST
  MULTIPERM_NEXT computes multipermutations in
  lexical order.

     1   1   2   2   3   3   3
     2   1   2   3   2   3   3
     3   1   2   3   3   2   3
     4   1   2   3   3   3   2
     5   1   3   2   2   3   3
     6   1   3   2   3   2   3
     7   1   3   2   3   3   2
     8   1   3   3   2   2   3
     9   1   3   3   2   3   2
    10   1   3   3   3   2   2
    11   2   1   2   3   3   3
    12   2   1   3   2   3   3
    13   2   1   3   3   2   3
    14   2   1   3   3   3   2
    15   2   2   1   3   3   3
    16   2   2   3   1   3   3
    17   2   2   3   3   1   3
    18   2   2   3   3   3   1
    19   2   3   1   2   3   3
    20   2   3   1   3   2   3
    21   2   3   1   3   3   2
    22   2   3   2   1   3   3
    23   2   3   2   3   1   3
    24   2   3   2   3   3   1
    25   2   3   3   1   2   3
    26   2   3   3   1   3   2
    27   2   3   3   2   1   3
    28   2   3   3   2   3   1
    29   2   3   3   3   1   2
    30   2   3   3   3   2   1
    31   3   1   2   2   3   3
    32   3   1   2   3   2   3
    33   3   1   2   3   3   2
    34   3   1   3   2   2   3
    35   3   1   3   2   3   2
    36   3   1   3   3   2   2
    37   3   2   1   2   3   3
    38   3   2   1   3   2   3
    39   3   2   1   3   3   2
    40   3   2   2   1   3   3
    41   3   2   2   3   1   3
    42   3   2   2   3   3   1
    43   3   2   3   1   2   3
    44   3   2   3   1   3   2
    45   3   2   3   2   1   3
    46   3   2   3   2   3   1
    47   3   2   3   3   1   2
    48   3   2   3   3   2   1
    49   3   3   1   2   2   3
    50   3   3   1   2   3   2
    51   3   3   1   3   2   2
    52   3   3   2   1   2   3
    53   3   3   2   1   3   2
    54   3   3   2   2   1   3
    55   3   3   2   2   3   1
    56   3   3   2   3   1   2
    57   3   3   2   3   2   1
    58   3   3   3   1   2   2
    59   3   3   3   2   1   2
    60   3   3   3   2   2   1

NIM_SUM_TEST
  NIM_SUM computes the Nim sum of two integers.

    I    J    Nim(I+J)


  I1, I2, I3 in decimal:

    218
    957
    871

  I1, I2, I3 in binary:


 
  00000000000000000000000011011010

 
  00000000000000000000001110111101

 
  00000000000000000000001101100111

  I1, I2, I3 in decimal:

    830
    562
    268

  I1, I2, I3 in binary:


 
  00000000000000000000001100111110

 
  00000000000000000000001000110010

 
  00000000000000000000000100001100

  I1, I2, I3 in decimal:

    415
     66
    477

  I1, I2, I3 in binary:


 
  00000000000000000000000110011111

 
  00000000000000000000000001000010

 
  00000000000000000000000111011101

  I1, I2, I3 in decimal:

    257
    110
    367

  I1, I2, I3 in binary:


 
  00000000000000000000000100000001

 
  00000000000000000000000001101110

 
  00000000000000000000000101101111

  I1, I2, I3 in decimal:

     43
    634
    593

  I1, I2, I3 in binary:


 
  00000000000000000000000000101011

 
  00000000000000000000001001111010

 
  00000000000000000000001001010001

PADOVAN_TEST
  PADOVAN computes the Padovan numbers.


   N    P(N)

     0       1
     1       1
     2       1
     3       2
     4       2
     5       3
     6       4
     7       5
     8       7
     9       9

PELL_BASIC_TEST
  PELL_BASIC solves the basic Pell equation.

       D       X        Y         R

        2          3          2          1
        3          2          1          1
        5          9          4          1
        6          5          2          1
        7          8          3          1
        8          3          1          1
       10         19          6          1
       11         10          3          1
       12          7          2          1
       13        649        180          1
       14         15          4          1
       15          4          1          1
       17         33          8          1
       18         17          4          1
       19        170         39          1
       20          9          2          1

PELL_NEXT_TEST
  PELL_NEXT computes the next solution.

       D       X        Y         R

        2          3          2          1
                  17         12          1
        3          2          1          1
                   7          4          1
        5          9          4          1
                 161         72          1
        6          5          2          1
                  49         20          1
        7          8          3          1
                 127         48          1
        8          3          1          1
                  17          6          1
       10         19          6          1
                 721        228          1
       11         10          3          1
                 199         60          1
       12          7          2          1
                  97         28          1
       13        649        180          1
              842401     233640          1
       14         15          4          1
                 449        120          1
       15          4          1          1
                  31          8          1
       17         33          8          1
                2177        528          1
       18         17          4          1
                 577        136          1
       19        170         39          1
               57799      13260          1
       20          9          2          1
                 161         36          1

PENT_ENUM_TEST
  PENT_ENUM counts points in pentagons.

   N  Pent(N)

   0       0
   1       1
   2       5
   3      12
   4      22
   5      35
   6      51
   7      70
   8      92
   9     117
  10     145

PERM_ASCEND_TEST
  PERM_ASCEND determines the length of the longest
  increasing subsequence in a permutation.

  The permutation:

     0   1   2   3   4   5   6   7   8
     1   2   8   5   6   7   4   3   0

  The length of the longest increasing subsequence is 5

  A longest increasing subsequence:
       1         1
       2         2
       3         5
       4         6
       5         7

PERM_FIXED_ENUM_TEST
  PERM_FIXED_ENUM enumerates the permutations
  of N objects that leave M unchanged.

  For this test, N = 10

    M    F(N,M)

    0   1334961
    1   1334960
    2    667485
    3    222480
    4     55650
    5     11088
    6      1890
    7       240
    8        45
    9         0
   10         1

PERM0_BREAK_COUNT_TEST
  PERM0_BREAK_COUNT counts the breaks in a permutation.

  The permutation:

     0   1   2   3   4   5
     3   4   1   0   5   2

  The number of breaks is 5

PERM0_CHECK_TEST
  PERM0_CHECK checks a permutation of (0,...,N-1).


  Permutation 1:

     0   1   2   3   4
     5   2   3   4   1

PERM0_CHECK - Warning!
  Permutation is missing value 0

  Permutation 2:

     0   1   2   3   4
     4   1   3   0   2

  Permutation 3:

     0   1   2   3   4
     0   2   1   3   2

PERM0_CHECK - Warning!
  Permutation is missing value 4

PERM0_CYCLE_TEST
  PERM0_CYCLE analyzes a permutation of (0,...,N-1).

  The permutation:

     0   1   2   3   4   5   6   7   8
     1   2   8   5   6   7   4   3   0

  NCYCLE = 3
  ISGN =   1

  The permutation in cycle form:

     0   1   2   3   4   5   6   7   8
    -3   2   8  -7  -8   7   4   3   0

PERM0_DISTANCE_TEST
  PERM0_DISTANCE computes the Ulam metric distance
  between two permutations of (0,...,N-1).

  Permutation P1

     0   1   2   3   4   5   6   7   8   9
     3   2   1   9   0   6   8   5   7   4

  Permutation P2

     0   1   2   3   4   5   6   7   8   9
     8   2   4   6   7   5   0   3   9   1

  Permutation P3

     0   1   2   3   4   5   6   7   8   9
     1   3   0   2   7   5   8   6   9   4

  K(P1,P1) should be 0.

  K(P1,P1) = 0

  K(P1,P2) should equal K(P2,P1).

  K(P1,P2) = 7
  K(P2,P1) = 7

  K(P1,P2) + K(P2,P3) >= K(P1,P3).

  K(P1,P3) = 6
  K(P1,P2) = 7
  K(P2,P3) = 6
  K(P1,P2) + K(P2,P3) = 13

PERM0_FREE_TEST
  PERM0_FREE returns the unused values in a partial permutation
  of (0,...,N-1).

  Partial permutation:
  (empty vector)

  Values not yet used:
           0           1           2           3           4

  Partial permutation:
           4

  Values not yet used:
           0           1           2           3

  Partial permutation:
           4           1

  Values not yet used:
           0           2           3

  Partial permutation:
           4           1           2

  Values not yet used:
           0           3

  Partial permutation:
           4           1           2           3

  Values not yet used:
           0

  Partial permutation:
           4           1           2           3           0

  Values not yet used:
  (empty vector)

PERM0_INVERSE_TEST
  PERM0_INVERSE inverts a permutation of (0,...,N-1);


  The original permutation:

     0   1   2   3   4   5   6
     3   2   4   0   6   5   1

  The inverted permutation:

     0   1   2   3   4   5   6
     3   6   1   0   2   5   4

PERM0_INVERSE2_TEST
  PERM0_INVERSE2 inverts a permutation of (0,...,N-1).

  The original permutation:

     0   1   2   3   4   5   6
     3   2   4   0   6   5   1

  The inverted permutation:

     0   1   2   3   4   5   6
     3   6   1   0   2   5   4

PERM0_INVERSE3_NEW_TEST
  PERM0_INVERSE3_NEW inverts a permutation of (0,...,N-1).

  The original permutation:

     0   1   2   3   4   5   6
     3   2   4   0   6   5   1

  The inverted permutation:

     0   1   2   3   4   5   6
     3   6   1   0   2   5   4

PERM0_LEX_NEXT_TEST
  PERM0_LEX_NEXT generates permutations in order.


 

     0   1   2   3
     0   1   2   3

 

     0   1   2   3
     0   1   3   2

 

     0   1   2   3
     0   2   1   3

 

     0   1   2   3
     0   2   3   1

 

     0   1   2   3
     0   3   1   2

 

     0   1   2   3
     0   3   2   1

 

     0   1   2   3
     1   0   2   3

 

     0   1   2   3
     1   0   3   2

 

     0   1   2   3
     1   2   0   3

 

     0   1   2   3
     1   2   3   0

 

     0   1   2   3
     1   3   0   2

 

     0   1   2   3
     1   3   2   0

 

     0   1   2   3
     2   0   1   3

 

     0   1   2   3
     2   0   3   1

 

     0   1   2   3
     2   1   0   3

 

     0   1   2   3
     2   1   3   0

 

     0   1   2   3
     2   3   0   1

 

     0   1   2   3
     2   3   1   0

 

     0   1   2   3
     3   0   1   2

 

     0   1   2   3
     3   0   2   1

 

     0   1   2   3
     3   1   0   2

 

     0   1   2   3
     3   1   2   0

 

     0   1   2   3
     3   2   0   1

 

     0   1   2   3
     3   2   1   0

PERM0_MUL_TEST
  PERM0_MUL multiplies two permutations of (0,...,N-1).


  Permutation P1:

     0   1   2   3   4
     1   4   0   2   3

  Permutation P2:

     0   1   2   3   4
     2   1   0   3   4

  Product permutation: P3

     0   1   2   3   4
     1   4   2   0   3

PERM0_NEXT_TEST
  PERM0_NEXT generates permutations of (0,...,N-1).

     0   1   2   3
     1   0   2   3
     2   0   1   3
     0   2   1   3
     1   2   0   3
     2   1   0   3
     3   1   0   2
     1   3   0   2
     0   3   1   2
     3   0   1   2
     1   0   3   2
     0   1   3   2
     0   2   3   1
     2   0   3   1
     3   0   2   1
     0   3   2   1
     2   3   0   1
     3   2   0   1
     3   2   1   0
     2   3   1   0
     1   3   2   0
     3   1   2   0
     2   1   3   0
     1   2   3   0

PERM0_NEXT2_TEST
  PERM0_NEXT2 generates permutations of (0,...,N-1).

     1   2   3   4
     1   2   4   3
     1   4   2   3
     4   1   2   3
     4   1   3   2
     1   4   3   2
     1   3   4   2
     1   3   2   4
     3   1   2   4
     3   1   4   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     3   2   4   1
     3   2   1   4
     2   3   1   4
     2   3   4   1
     2   4   3   1
     4   2   3   1
     4   2   1   3
     2   4   1   3
     2   1   4   3
     2   1   3   4

PERM0_NEXT3_TEST
  PERM0_NEXT3 generates permutations of (0,...,N-1).

     1   2   3   4
     1   2   4   3
     1   4   2   3
     4   1   2   3
     4   1   3   2
     1   4   3   2
     1   3   4   2
     1   3   2   4
     3   1   2   4
     3   1   4   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     3   2   4   1
     3   2   1   4
     2   3   1   4
     2   3   4   1
     2   4   3   1
     4   2   3   1
     4   2   1   3
     2   4   1   3
     2   1   4   3
     2   1   3   4

PERM0_PRINT_TEST
  PERM0_PRINT prints a permutation of (0,...,N-1).

  The 0-based permutation:

     0   1   2   3   4   5   6
     6   1   3   0   4   2   5

PERM0_RANDOM_TEST
  PERM0_RANDOM produces a random permutation of (0,...,N-1);
  For this test, N = 4

     0   3   1   2
     2   0   1   3
     1   0   2   3
     2   1   0   3
     1   3   0   2

PERM0_RANDOM2_TEST
  PERM0_RANDOM2 produces a random permutation of (0,...,N-1);
  For this test, N = 4

     1   0   3   2
     3   0   2   1
     0   2   3   1
     3   1   0   2
     2   3   1   0

PERM0_RANK_TEST
  PERM0_RANK ranks a permutation of (0,...,N-1).

  The permutation:

     0   1   2   3
     0   3   1   2

  The rank is 3

PERM0_SIGN_TEST
  PERM0_SIGN computes the sign of a permutation of (0,...,N-1).

  RANK  SIGN  Permutation

   0    -1     0     1     2     3  
   1     1     0     1     3     2  
   2     1     0     2     1     3  
   3    -1     0     2     3     1  
   4    -1     0     3     1     2  
   5     1     0     3     2     1  
   6     1     1     0     2     3  
   7    -1     1     0     3     2  
   8    -1     1     2     0     3  
   9     1     1     2     3     0  
  10     1     1     3     0     2  
  11    -1     1     3     2     0  
  12    -1     2     0     1     3  
  13     1     2     0     3     1  
  14     1     2     1     0     3  
  15    -1     2     1     3     0  
  16    -1     2     3     0     1  
  17     1     2     3     1     0  
  18     1     3     0     1     2  
  19    -1     3     0     2     1  
  20    -1     3     1     0     2  
  21     1     3     1     2     0  
  22     1     3     2     0     1  
  23    -1     3     2     1     0  

PERM0_TO_EQUIV_TEST
  PERM0_TO_EQUIV returns the set partition
  or equivalence classes determined by a
  permutation of (0,...,N-1).

  The input permutation:

     0   1   2   3   4   5   6   7   8
     1   2   8   5   6   7   4   3   0

  The partition:
  Set    Size  Elements
     1     1 ::    1  
     2     1 ::    2  
     3     2 ::    3     8  
     4     4 ::    4     5     6     7  
     5     1 ::    9  

PERM0_TO_INVERSION_TEST
  PERM0_TO_INVERSION: permutation (0,...,N-1) to inversion.


  The permutation:
       1         2
       2         4
       3         0
       4         3
       5         1

  The inversion sequence:
       1         0
       2         0
       3         2
       4         1
       5         3

  The recovered permutation:
       1         2
       2         4
       3         0
       4         3
       5         1

PERM0_TO_YTB_TEST
  PERM0_TO_YTB converts a permutation of (0,...,N-1) to a
  Young tableau.

  The permutation:

     0   1   2   3   4   5   6
     7   2   4   1   5   3   6

  The Young tableau:
     1       3       5       6  
     2       4  
     7  

PERM0_UNRANK_TEST
  PERM0_UNRANK, given a rank, computes the
  corresponding permutation of (0,...,N-1).

  The requested rank is 6

  The permutation:

     0   1   2   3
     0   3   2   1

PERM1_CANON_TO_CYCLE_TEST
  PERM1_CANON_TO_CYCLE converts a permutation of (1,...,N) from
  canonical to cycle form.

  The permutation in canonical form:

     1   2   3   4   5   6
     4   5   2   1   6   3

  The permutation in cycle form:

     1   2   3   4   5   6
    -4   5  -2  -1   6   3

PERM1_CHECK_TEST
  PERM1_CHECK checks a permutation of (1,...,N).


  Permutation 1:

     1   2   3   4   5
     5   2   3   4   1

  Permutation 2:

     1   2   3   4   5
     4   1   3   0   2

PERM1_CHECK - Warning!
  Permutation is missing value 5

  Permutation 3:

     1   2   3   4   5
     0   2   1   3   2

PERM1_CHECK - Warning!
  Permutation is missing value 4

PERM1_CYCLE_TO_CANON_TEST
  PERM1_CYCLE_TO_CANON converts a permutation of (1,...,N) from
  cycle to canonical form.

  The permutation in cycle form:

     1   2   3   4   5   6
    -6   3   1  -5   4  -2

  The permutation in canonical form:

     1   2   3   4   5   6
     4   5   2   1   6   3

PERM1_CYCLE_TO_INDEX_TEST
  PERM1_CYCLE_TO_INDEX converts a permutation of (1,...,N) from
  cycle to standard index form.

  The standard index form permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The permutation in cycle form:

     1   2   3   4   5   6   7   8   9
    -1   2   3   9  -4   6   8  -5   7

  The standard index form permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

PERM1_INDEX_TO_CYCLE_TEST
  PERM1_INDEX_TO_CYCLE converts a permutation of (1,...,N) from
  standard index to cycle form.

  The standard index form permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The permutation in cycle form:

     1   2   3   4   5   6   7   8   9
    -1   2   3   9  -4   6   8  -5   7

  The standard index form permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

PERM1_PRINT_TEST
  PERM1_PRINT prints a permutation of (1,...,N).

  The 1-based permutation:

     1   2   3   4   5   6   7
     7   2   4   1   5   3   6

PERRIN_TEST
  PERRIN computes the Perrin numbers.


   N    P(N)

     0       3
     1       0
     2       2
     3       3
     4       2
     5       5
     6       5
     7       7
     8      10
     9      12

PORD_CHECK_TEST
  PORD_CHECK checks a partial ordering.

  The partial ordering matrix:

  Col:          1             2             3             4             5             6             7             8             9            10       
  Row
  ---
    1       1       0       0       0       0       0       0       0       0       0  
    2       0       1       0       1       0       1       0       1       0       0  
    3       1       0       1       1       0       0       0       0       0       0  
    4       0       0       0       1       0       0       0       0       0       0  
    5       1       1       1       1       1       1       1       1       0       1  
    6       0       0       0       1       0       1       0       1       0       0  
    7       1       0       1       1       0       1       1       1       0       1  
    8       0       0       0       1       0       0       0       1       0       0  
    9       0       0       0       0       0       0       0       0       0       0  
   10       1       0       1       1       0       0       0       1       0       1  

  CHECK FLAG = 0
  0 means no error.
  1 means illegal value of N.
  2 means some A(I,J) and A(J,I) are both nonzero.

POWER_MOD_TEST
  POWER_MOD computes the remainder of a power
  of an integer modulo another integer.

  A = 7
  N = 50
  M = 11
  mod ( A^N, M ) = 1

  A = 3
  N = 118
  M = 119
  mod ( A^N, M ) = 32

POWER_SERIES1_TEST
  POWER_SERIES1 composes a power series;

  Power series of G(x) = (1+F(x))**alpha

  N = 10
  ALPHA = 7

  Series for F(x):
         0             1
         1             0
         2             0
         3             0
         4             0
         5             0
         6             0
         7             0
         8             0
         9             0

  Series for G(X):
         0             7
         1            21
         2            35
         3            35
         4            21
         5             7
         6             1
         7             0
         8             0
         9             0

POWER_SERIES2_TEST
  POWER_SERIES2 composes a power series;

  Power series of G(x) = exp(F(x))-1

  N = 4

  Series for F(X):
         0            -4
         1             0
         2             0
         3             0

  Series for G(X):
         0            -4
         1             8
         2      -10.6667
         3       10.6667

POWER_SERIES3_TEST
  POWER_SERIES3 composes two power series;

  Series for F(X):
         0             1
         1             1
         2             0
         3             0

  Series for G(X):
         0             1
         1             1
         2             0
         3             0

  Series for H(X) = G(F(X)):
         0             1
         1             2
         2             2
         3             3

POWER_SERIES4_TEST
  POWER_SERIES4 composes a power series;
  Given power series for F(X) and G(X), we compute
  the power series of H(x) = G(1/F(x)).

  Series for F(x):
         0             1
         1           0.5
         2      0.333333
         3          0.25
         4           0.2
         5      0.166667
         6      0.142857
         7         0.125
         8      0.111111
         9           0.1

  Series for G(x):
         0             1
         1             0
         2             0
         3             0
         4             0
         5             0
         6             0
         7             0
         8             0
         9             0

  Series for H(x):
         0             1
         1          -0.5
         2      0.166667
         3    -0.0416667
         4    0.00833333
         5   -0.00138889
         6   0.000198413
         7  -2.48016e-05
         8   2.75573e-06
         9  -2.75573e-07

PRIME_TEST
  PRIME returns primes from a table.

  Number of primes stored is 1600

     I    Prime(I)

     1       2
     2       3
     3       5
     4       7
     5      11
     6      13
     7      17
     8      19
     9      23
    10      29

  1590   13411
  1591   13417
  1592   13421
  1593   13441
  1594   13451
  1595   13457
  1596   13463
  1597   13469
  1598   13477
  1599   13487
  1600   13499

PYTHAG_TRIPLE_NEXT_TEST
  PYTHAG_TRIPLE_NEXT computes the next
  Pythagorean triple.

     I       J       A       B       C A^2+B^2     C^2

     2       1       3       4       5      25      25
     3       2       5      12      13     169     169
     4       1      15       8      17     289     289
     4       3       7      24      25     625     625
     5       2      21      20      29     841     841
     5       4       9      40      41    1681    1681
     6       1      35      12      37    1369    1369
     6       3      27      36      45    2025    2025
     6       5      11      60      61    3721    3721
     7       2      45      28      53    2809    2809
     7       4      33      56      65    4225    4225
     7       6      13      84      85    7225    7225
     8       1      63      16      65    4225    4225
     8       3      55      48      73    5329    5329
     8       5      39      80      89    7921    7921
     8       7      15     112     113   12769   12769
     9       2      77      36      85    7225    7225
     9       4      65      72      97    9409    9409
     9       6      45     108     117   13689   13689
     9       8      17     144     145   21025   21025
    10       1      99      20     101   10201   10201

R8_AGM_TEST
  R8_AGM computes the arithmetic-geometric mean (AGM)
  of two nonnegative real numbers.

    X        Y    R8_AGM(X,Y)

         3          10     5.97767
         9           6     7.42404
         5           1     2.60401
         3           2     2.47468
         1           7     3.28792
         1           5     2.60401
         5           8     6.41198
         8           1     3.61576
         9           4      6.2475
         1           1           1

R8_CHOOSE_TEST
  R8_CHOOSE evaluates C(N,K).

     N     K    CNK

     0       0       1
     1       0       1
     1       1       1
     2       0       1
     2       1       2
     2       2       1
     3       0       1
     3       1       3
     3       2       3
     3       3       1
     4       0       1
     4       1       4
     4       2       6
     4       3       4
     4       4       1

R8_EPSILON_TEST
  R8_EPSILON produces the floating point machine precision.

  R = R8_EPSILON() = 2.22045e-16
  ( 1 + R ) - 1 = 2.22045e-16
  ( 1 + (R/2) ) - 1 =          0

R8_FALL_TEST
  R8_FALL evaluates the falling factorial Fall(X,N).

    X          N                Exact                  Computed

         5     4                       120                       120
      5.25     4              163.16015625              163.16015625
       5.5     4                  216.5625                  216.5625
      5.75     4              281.66015625              281.66015625
         6     4                       360                       360
       7.5     0                         1                         1
       7.5     1                       7.5                       7.5
       7.5     2                     48.75                     48.75
       7.5     3                   268.125                   268.125
       7.5     4                 1206.5625                 1206.5625
       7.5     5                4222.96875                4222.96875
       7.5     6              10557.421875              10557.421875
       7.5     7             15836.1328125             15836.1328125
       7.5     8             7918.06640625             7918.06640625
       7.5     9           -3959.033203125           -3959.033203125

R8_RISE_TEST
  R8_RISE evaluates the rising factorial Fall(X,N).

    X          N                Exact                  Computed

         5     4                      1680                      1680
      5.25     4             1962.59765625             1962.59765625
       5.5     4                 2279.0625                 2279.0625
      5.75     4             2631.97265625             2631.97265625
         6     4                      3024                      3024
       7.5     0                         1                         1
       7.5     1                       7.5                       7.5
       7.5     2                     63.75                     63.75
       7.5     3                   605.625                   605.625
       7.5     4                 6359.0625                 6359.0625
       7.5     5               73129.21875               73129.21875
       7.5     6             914115.234375             914115.234375
       7.5     7          12340555.6640625          12340555.6640625
       7.5     8         178938057.1289063         178938057.1289062
       7.5     9         2773539885.498047         2773539885.498047

R8_TO_CFRAC_TEST
  R8_TO_CFRAC converts a double precision number to
  a sequence of continued fraction convergents.

  Use the real number R = 6.28319

             6             6             1               6        0.283185
             3            19             3         6.33333       -0.050148
             1            25             4            6.25       0.0331853
             1            44             7         6.28571     -0.00252898
             7           333            53         6.28302     0.000166439
             2           710           113         6.28319    -5.33528e-07
           146        103993         16551         6.28319     1.15578e-09
             3        312689         49766         6.28319    -5.82867e-11
             6       1980127        315147         6.28319     5.47384e-12
             1       2292816        364913         6.28319    -3.22142e-12
             1       4272943        680060         6.28319     8.08242e-13

R8_TO_DEC_TEST
  R8_TO_DEC converts a real number to a decimal;

  The maximum number of digits allowed is 5

     R   =>  A * 10^B  =>  R2

    -5.63163  -56316      -4     -5.6316
     9.12635   91264      -4      9.1264
     6.59018   65902      -4      6.5902
     1.23391   12339      -4      1.2339
    -1.69386  -16939      -4     -1.6939
    -8.67763  -86776      -4     -8.6776
    -4.84844  -48484      -4     -4.8484
    -7.80086  -78009      -4     -7.8009
    -9.12342  -91234      -4     -9.1234
     2.67931   26793      -4      2.6793

R8_TO_RAT_TEST
  R8_TO_RAT converts a real number to a rational;

  The maximum number of digits allowed is 4

     R   =>  A / B  =>  R2

   -0.315817   -1579    5000     -0.3158
     7.06318    8829    1250      7.0632
     5.79509   57951   10000      5.7951
     3.11695    3117    1000       3.117
     1.65307   16531   10000      1.6531
    -1.83881   -4597    2500     -1.8388
   0.0757779     379    5000      0.0758
    -1.40043   -3501    2500     -1.4004
    -2.06171  -20617   10000     -2.0617
     3.83966   38397   10000      3.8397

R8MAT_DET_TEST
  R8MAT_DET: determinant of a real matrix.


  The 123/456/789 matrix:

  Col:          1             2             3       
  Row
  ---
    1             1             2             3  
    2             4             5             6  
    3             7             8             9  

  Determinant of the 123/456/789 matrix is 0

  The Hilbert matrix:

  Col:          1             2             3             4       
  Row
  ---
    1           0.5      0.333333          0.25           0.2  
    2      0.333333          0.25           0.2      0.166667  
    3          0.25           0.2      0.166667      0.142857  
    4           0.2      0.166667      0.142857         0.125  

  Determinant of the Hilbert matrix is 2.36206e-09

  The -1,2,-1 matrix:

  Col:          1             2             3       
  Row
  ---
    1             2            -1             0  
    2            -1             2            -1  
    3             0            -1             2  

  Determinant of the -1,2,-1 matrix is 4

R8MAT_PERM0_TEST
  R8MAT_PERM0 reorders a real matrix in place.
  The rows and columns use the same permutation.

  The original matrix

  Col:          1             2             3             4             5       
  Row
  ---
    1            11            12            13            14            15  
    2            21            22            23            24            25  
    3            31            32            33            34            35  
    4            41            42            43            44            45  
    5            51            52            53            54            55  
    6            61            62            63            64            65  
    7            71            72            73            74            75  
    8            81            82            83            84            85  
    9            91            92            93            94            95  

  Col:          6             7             8             9       
  Row
  ---
    1            16            17            18            19  
    2            26            27            28            29  
    3            36            37            38            39  
    4            46            47            48            49  
    5            56            57            58            59  
    6            66            67            68            69  
    7            76            77            78            79  
    8            86            87            88            89  
    9            96            97            98            99  

  The row and column permutation:

     0   1   2   3   4   5   6   7   8
     1   2   8   5   6   7   4   3   0

  The permuted matrix

  Col:          1             2             3             4             5       
  Row
  ---
    1            99            91            92            98            97  
    2            19            11            12            18            17  
    3            29            21            22            28            27  
    4            89            81            82            88            87  
    5            79            71            72            78            77  
    6            49            41            42            48            47  
    7            59            51            52            58            57  
    8            69            61            62            68            67  
    9            39            31            32            38            37  

  Col:          6             7             8             9       
  Row
  ---
    1            94            95            96            93  
    2            14            15            16            13  
    3            24            25            26            23  
    4            84            85            86            83  
    5            74            75            76            73  
    6            44            45            46            43  
    7            54            55            56            53  
    8            64            65            66            63  
    9            34            35            36            33  

R8MAT_2PERM0_TEST
  R8MAT_2PERM0 reorders a real matrix in place.
  Rows and columns use different permutations.

  The original matrix

  Col:          1             2             3             4             5       
  Row
  ---
    1            11            12            13            14            15  
    2            21            22            23            24            25  
    3            31            32            33            34            35  
    4            41            42            43            44            45  
    5            51            52            53            54            55  
    6            61            62            63            64            65  
    7            71            72            73            74            75  
    8            81            82            83            84            85  
    9            91            92            93            94            95  

  Col:          6             7       
  Row
  ---
    1            16            17  
    2            26            27  
    3            36            37  
    4            46            47  
    5            56            57  
    6            66            67  
    7            76            77  
    8            86            87  
    9            96            97  

  The row permutation:

     0   1   2   3   4   5   6   7   8
     1   2   8   5   6   7   4   3   0

  The column permutation:

     0   1   2   3   4   5   6
     2   3   4   5   6   0   1

  The permuted matrix

  Col:          1             2             3             4             5       
  Row
  ---
    1            11            12            13            14            15  
    2            21            22            23            24            25  
    3            31            32            33            34            35  
    4            41            42            43            44            45  
    5            51            52            53            54            55  
    6            61            62            63            64            65  
    7            71            72            73            74            75  
    8            81            82            83            84            85  
    9            91            92            93            94            95  

  Col:          6             7       
  Row
  ---
    1            16            17  
    2            26            27  
    3            36            37  
    4            46            47  
    5            56            57  
    6            66            67  
    7            76            77  
    8            86            87  
    9            96            97  

R8MAT_PERMANENT_TEST
  R8MAT_PERMANENT: the matrix permanent function.
  We will analyze matrices with 0 diagonal and
  1 on all offdiagonals.

  Order	    Permanent.

DEBUG
   2           1
DEBUG, N = 2
   3           2
DEBUG, N = 3
   4           9
DEBUG, N = 4
   5          44
DEBUG, N = 5
   6         265
DEBUG, N = 6
   7        1854
DEBUG, N = 7
   8       14833
DEBUG, N = 8
   9      133496
DEBUG, N = 9
  10  1.33496e+06
DEBUG, N = 10
  11  1.46846e+07
DEBUG, N = 11
  12  1.76215e+08
DEBUG, N = 12

R8POLY_TEST
  R8POLY converts between power sum, factorial
  and Taylor forms, and can evaluate a polynomial


  All calls  have input A as follows:
         0             0
         1             0
         2             0
         3             0
         4             0
         5             1

  Option IOPT = -3

  Output array:
         0             0
         1            24
         2           -50
         3            35
         4           -10
         5             1

  Option IOPT = -2

  Output array:
         0             0
         1             1
         2            15
         3            25
         4            10
         5             1

  Option IOPT = -1
  X0 = 2
  Value = 0

  Option IOPT = 0
  X0 = 2
  Value = 32

  Option IOPT = 6
  X0 = 2

  Output array:
         0            32
         1            80
         2            80
         3            40
         4            10
         5             1

  Option IOPT = 6
  X0 = -2

  Output array:
         0           -32
         1            80
         2           -80
         3            40
         4           -10
         5             1

R8POLY_ADD_TEST
  R8POLY_ADD adds two polynomials.

  Polynomial A:
  p(x) =  5.5 * x^5
         +4.4 * x^4
         +3.3 * x^3
         +2.2 * x^2
         +1.1 * x

  Polynomial B:
  p(x) = -5.5 * x^5
         +8.3 * x^3
         +7.2 * x^2
         -2.1 * x
         +1

  Polynomial C = A+B:
  p(x) =  4.4 * x^4
         +11.6 * x^3
         +9.4 * x^2
         -1 * x
         +1

R8POLY_DEGREE_TEST
  R8POLY_DEGREE determines the degree of an R8POLY.

  The polynomial:
  p(x) =  4.4 * x^4
         +3.3 * x^3
         +1.1 * x

The polyomial degree = 4

R8POLY_DIF_TEST
  R8POLY_DIF computes derivatives of an R8POLY.


  The polynomial A:
  p(x) =  1 * x^3
         +2 * x^2
         -5 * x
         -6

  Differentiate A 1 times.

  The derivative, B:
  p(x) =  3 * x^2
         +4 * x
         -5

  The polynomial A:
  p(x) =  1 * x^4
         +3 * x^3
         +2 * x^2
         +5 * x
         -2

  Differentiate A 3 times.

  The derivative, B:
  p(x) =  24 * x
         +18

R8POLY_DIV_TEST
  R8POLY_DIV computes the quotient and
  remainder for polynomial division.


  The polynomial to be divided, A:
  p(x) =  1 * x^3
         +2 * x^2
         -5 * x
         -6

  The divisor polynomial, B:
  p(x) =  1 * x
         -2

  The quotient polynomial, Q:
  p(x) =  1 * x^2
         +4 * x
         +3

  The remainder polynomial, R:
  p(x) =  0

  The polynomial to be divided, A:
  p(x) =  1 * x^4
         +3 * x^3
         +2 * x^2
         +5 * x
         -2

  The divisor polynomial, B:
  p(x) =  1 * x^2
         +1 * x
         -3

  The quotient polynomial, Q:
  p(x) =  1 * x^2
         +2 * x
         +3

  The remainder polynomial, R:
  p(x) =  8 * x
         +7

R8POLY_F2P_TEST
  R8POLY_F2P: factorial => power sum.

  The power sum polynomial:
  p(x) =  4 * x^3
         +3 * x^2
         +2 * x
         +1

  The factorial coefficients:
         0             1
         1             9
         2            15
         3             4

  The recovered power sum polynomial:
  p(x) =  4 * x^3
         +3 * x^2
         +2 * x
         +1

R8POLY_FVAL_TEST
  R8POLY_FVAL evaluates a polynomial in factorial form.

  The factorial coefficients:
         0             1
         1             2
         2             3
         3             4
         4             5

  RPOLY (2) = 11
  The correct value is 11.

R8POLY_MUL_TEST
  R8POLY_MUL multiplies two polynomials.


  The factor A:
  p(x) =  1 * x
         +1

  The factor B:
  p(x) = -1 * x
         +1

  The product C = A*B:
  p(x) = -1 * x^2
         +1

  The factor A:
  p(x) =  3 * x^2
         +2 * x
         +1

  The factor B:
  p(x) = -2 * x
         +1

  The product C = A*B:
  p(x) = -6 * x^3
         -1 * x^2
         +1

R8POLY_N2P_TEST
  R8POLY_N2P: Newton => power sum;

  The power sum polynomial:
  p(x) =  4 * x^3
         +3 * x^2
         +2 * x
         +1

  Derived Newton form coefficients:
         0            49
         1           132
         2            51
         3             4

  Newton form abscissas:
         0             2
         1             4
         2             6
         3             8

  The recovered power sum polynomial:
  p(x) =  4 * x^3
         +3 * x^2
         +2 * x
         +1

R8POLY_NVAL_TEST
  R8POLY_NVAL evaluates a polynomial in Newton form.

  Newton polynomial coefficients:
         0             1
         1             2
         2             3
         3             4
         4             5

  Newton polynomial abscissas:
         0             0
         1             1
         2             2
         3             3
         4             4

  RPOLY (2) = 11
  The correct value is 11.

R8POLY_NXL_TEST
  R8POLY_NX replaces one abscissa in a Newton polynomial.

  Newton polynomial coefficients:
         0             1
         1             2
         2             3

  Newton polynomial abscissas:
         0             1
         1             2
         2             3

  Replace one abscissa by X = 0

  Revised Newton polynomial coefficients:
         0             5
         1            -4
         2             3

  Revised Newton polynomial abscissas:
         0             0
         1             1
         2             2

R8POLY_P2F_TEST
  R8POLY_P2F: power sum => factorial;

  The power sum polynomial:
  p(x) =  4 * x^3
         +3 * x^2
         +2 * x
         +1

  The factorial coefficients:
         0             1
         1             9
         2            15
         3             4

  The recovered power sum polynomial:
  p(x) =  4 * x^3
         +3 * x^2
         +2 * x
         +1

R8POLY_P2N_TEST
  R8POLY_P2N: Power sum => Newton.

  The power sum polynomial:
  p(x) =  4 * x^3
         +3 * x^2
         +2 * x
         +1

  Derived Newton form coefficients:
         0            49
         1           132
         2            51
         3             4

  Newton form abscissas:
         0             2
         1             4
         2             6
         3             8

  The recovered power sum polynomial:
  p(x) =  4 * x^3
         +3 * x^2
         +2 * x
         +1

R8POLY_P2T_TEST
  R8POLY_P2T: Power sum => Taylor.
  The Taylor form uses the base point X0 = 2

  Initial Taylor sum form:
         0             1
         1             2
         2             3
         3             4

  Power sum form:
  p(x) =  5 * x^4
         +4 * x^3
         -21 * x^2
         +38 * x
         -23

  Recovered Taylor sum form:
         0             1
         1             2
         2             3
         3             4

R8POLY_POWER_TEST
  R8POLY_POWER takes a polynomial to a power.

  The polynomial A:
  p(x) = -1 * x
         +2

  Raised to the power 3:
  p(x) = -1 * x^3
         +6 * x^2
         -12 * x
         +8

  The polynomial A:
  p(x) =  1 * x^2
         +1 * x

  Raised to the power 2:
  p(x) =  1 * x^4
         +2 * x^3
         +1 * x^2

R8POLY_PRINT_TEST
  R8POLY_PRINT prints an R8POLY.

  The polynomial:
  p(x) =  1.4 * x^4
         +3.3 * x^3
         +2.2 * x^2
         +5.1 * x
         -2

R8POLY_PVAL_TEST
  R8POLY_PVAL evaluates a polynomial
  in power sum form.

  The polynomial to be evaluated:
  p(x) =  5 * x^4
         +4 * x^3
         +3 * x^2
         +2 * x
         +1
  At X = 2
  Computed polynomial value is 129
  Correct value is 129.

R8POLY_T2P_TEST
  R8POLY_T2P: Taylor => Power sum;
  The Taylor form uses the base point X0 = 2

  Initial Taylor sum form:
         0             1
         1             2
         2             3
         3             4

  Power sum form:
  p(x) =  5 * x^4
         +4 * x^3
         -21 * x^2
         +38 * x
         -23

  Recovered Taylor sum form:
         0             1
         1             2
         2             3
         3             4

R8VEC_BACKTRACK_TEST
  I4VEC_BACKTRACK uses backtracking, seeking a vector X of
  N values which satisfies some condition.

  In this demonstration, we have 8 values W(I).
  We seek all subsets that sum to 53.0.
  X(I) is 0.0 or 1.0 if the entry is skipped or used.

   1           53:          15        22        16
   2           53:          15        14        16         8
   3           53:          22        14         9         8

  Done!

R8VEC_FRAC_TEST
  R8VEC_FRAC: K-th smallest real vector entry;

  The real array to search: 
         0       2.18418
         1       9.56318
         2       8.29509
         3       5.61695
         4       4.15307
         5      0.661187
         6       2.57578
         7       1.09957
         8       0.43829
         9       6.33966

Frac     Value

   1     0.43829
   2    0.661187
   3     1.09957
   4     2.18418
   5     2.57578
   6     4.15307
   7     5.61695
   8     6.33966
   9     8.29509
  10     9.56318

R8VEC_MIRROR_NEXT_TEST
  R8VEC_MIRROR_NEXT generates all sign variations
  of a real vector.

  Next vector:
         0             1
         1             2
         2             3

  Next vector:
         0            -1
         1             2
         2             3

  Next vector:
         0             1
         1            -2
         2             3

  Next vector:
         0            -1
         1            -2
         2             3

  Next vector:
         0             1
         1             2
         2            -3

  Next vector:
         0            -1
         1             2
         2            -3

  Next vector:
         0             1
         1            -2
         2            -3

  Next vector:
         0            -1
         1            -2
         2            -3

  Done.

  Next vector:
         0             1
         1             0
         2             3

  Next vector:
         0            -1
         1             0
         2             3

  Next vector:
         0             1
         1            -0
         2            -3

  Next vector:
         0            -1
         1            -0
         2            -3

  Done.

RAT_ADD_TEST
  RAT_ADD adds two rationals.

  A = 3/4
  B = 10/7
  C = A + B = 61/28

RAT_DIV_TEST
  RAT_DIV divides two rationals.

  A = 3/4
  B = 10/7
  C = A / B = 21/40

RAT_FAREY_TEST
  RAT_FAREY computes a row of the Farey fraction table.

  Row 1
  Number of fractions: 2

  0  1
  1  1

  Row 2
  Number of fractions: 3

  0  1  1
  1  2  1

  Row 3
  Number of fractions: 5

  0  1  1  2  1
  1  3  2  3  1

  Row 4
  Number of fractions: 7

  0  1  1  1  2  3  1
  1  4  3  2  3  4  1

  Row 5
  Number of fractions: 11

  0  1  1  1  2  1  3  2  3  4  1
  1  5  4  3  5  2  5  3  4  5  1

  Row 6
  Number of fractions: 13

  0  1  1  1  1  2  1  3  2  3  4  5  1
  1  6  5  4  3  5  2  5  3  4  5  6  1

  Row 7
  Number of fractions: 19

  0  1  1  1  1  2  1  2  3  1  4  3  2  5  3  4  5  6  1
  1  7  6  5  4  7  3  5  7  2  7  5  3  7  4  5  6  7  1

RAT_FAREY2_TEST
  RAT_FAREY2 computes a row of the Farey fraction table.

  Row 1

  0  1
  1  1

  Row 2

  0  1  1
  1  2  1

  Row 3

  0  1  1  2  1
  1  3  2  3  1

  Row 4

  0  1  1  2  1  3  2  3  1
  1  4  3  5  2  5  3  4  1

  Row 5

  0  1  1  2  1  3  2  3  1  4  3  5  2  5  3  4  1
  1  5  4  7  3  8  5  7  2  7  5  8  3  7  4  5  1

RAT_MUL_TEST
  RAT_MUL multiplies two rationals.

  A = 3/4
  B = 10/7
  C = A * B = 15/14

RAT_NORMALIZE_TEST
  RAT_NORMALIZE normalizes a rational.

       A       B         A       B
                         Normalized

       3       4         3       4
       1    1000         1    1000
      20       1        20       1
       8       4         2       1
     -10       7       -10       7
       9     -15        -3       5
     -11     -11         1       1

RAT_SUM_FORMULA_TEST
  RAT_SUM_FORMULA computes the coefficients for the
  formulas for the sums of powers of integers.


  Power Sum Coefficients:
   1     0     0     0     0     0     0  

   1     1     0     0     0     0     0  
   2     2     1     1     1     1     1  

   1     1     1     0     0     0     0  
   3     2     6     1     1     1     1  

   1     1     1     0     0     0     0  
   4     2     4     1     1     1     1  

   1     1     1     0    -1     0     0  
   5     2     3     1    30     1     1  

   1     1     5     0    -1     0     0  
   6     2    12     1    12     1     1  

   1     1     1     0    -1     0     1  
   7     2     2     1     6     1    42  

RAT_TO_CFRAC_TEST
  RAT_TO_CFRAC fraction => continued fraction,

  Regular fraction is 4096/15625

  Continued fraction coefficients:
       1         0
       2         3
       3         1
       4         4
       5         2
       6         1
       7         1
       8        11
       9        13

  The continued fraction convergents.
  The last row contains the value of the continued
  fraction, written as a common fraction.

  I, P(I), Q(I), P(I)/Q(I)

  0       0       1               0
  1       1       3        0.333333
  2       1       4            0.25
  3       5      19        0.263158
  4      11      42        0.261905
  5      16      61        0.262295
  6      27     103        0.262136
  7     313    1194        0.262144
  8    4096   15625        0.262144

RAT_TO_DEC_TEST
  RAT_TO_DEC fraction => decimal,

  In this test, choose the top and bottom
  of a rational at random, and compute the
  equivalent real number.

  Then convert to decimal, and the equivalent real.

  Then convert back to rational and the equivalent real.

  -0.588297 = -563/957
  -0.588297 = -588296760*10^(-9)
  -0.588297 = -14707419/25000000

  1.1726 = 659/562
  1.1726 = 1172597864*10^(-9)
  1.1726 = 146574733/125000000

  -2.52239 = -169/67
  -2.52239 = -252238805*10^(-8)
  -2.52239 = -50447761/20000000

  -4.40909 = -485/110
  -4.40909 = -440909090*10^(-8)
  -4.40909 = -44090909/10000000

  -1.44006 = -913/634
  -1.44006 = -1440063091*10^(-9)
  -1.44006 = -1440063091/1000000000

  -1.94889 = -877/450
  -1.94889 = -1948888888*10^(-9)
  -1.94889 = -243611111/125000000

  -0.260927 = -197/755
  -0.260927 = -260927152*10^(-9)
  -0.260927 = -16307947/62500000

  297.5 = 595/2
  297.5 = 2975*10^(-1)
  297.5 = 595/2

  2.26496 = 795/351
  2.26496 = 226495726*10^(-8)
  2.26496 = 113247863/50000000

  -57.9286 = -811/14
  -57.9286 = -579285714*10^(-7)
  -57.9286 = -289642857/5000000

RAT_TO_R8_TEST
  RAT_TO_R8 converts a rational to a real number.

  The maximum number of digits allowed is 4

     R   =>  A / B  =>  R2

   -0.315817   -1579    5000     -0.3158
     7.06318    8829    1250      7.0632
     5.79509   57951   10000      5.7951
     3.11695    3117    1000       3.117
     1.65307   16531   10000      1.6531
    -1.83881   -4597    2500     -1.8388
   0.0757779     379    5000      0.0758
    -1.40043   -3501    2500     -1.4004
    -2.06171  -20617   10000     -2.0617
     3.83966   38397   10000      3.8397

RAT_TO_S_TEST
  RAT_TO_S converts a rational to a string.

       A       B      S

       3       4      3/4
       1    1000      1/1000
      20       1      20/1
       8       4      8/4
     -10       7      -10/7
       9     -15      9/-15
     -11     -11      -11/-11

RAT_WIDTH_TEST
  RAT_WIDTH determines the "width" of a rational.

  Top    Bottom  Width

      1000         3         4
      1000        40         4
      1000       500         4
      1000      6000         4
      1000     70000         5
         1         1         1
        -1       200         3
       -10       200         3
      -100       200         4
     -1000       200         5
         1      -200         3
        10      -200         3
       100      -200         4
      1000      -200         5
     10000      -200         6
        17      3000         4
   4000000   4000000         7

RATMAT_DET_TEST
  RATMAT_DET: determinant of a rational matrix.



  The 123/456/789 matrix:
  1    2    3  

  4    5    6  

  7    8    9  

  Determinant of the 123/456/789 matrix = 0/1


  The Hilbert matrix:
  1    1    1  
  2    3    4  

  1    1    1  
  3    4    5  

  1    1    1  
  4    5    6  

  Determinant of the Hilbert matrix = 1/43200


  The -1 2 -1 matrix:
   2    -1     0  

  -1     2    -1  

   0    -1     2  

  Determinant of the -1,2,-1 matrix = 4/1

RATMAT_PRINT_TEST
  RATMAT_PRINT prints a rational matrix.



  The Hilbert matrix:
  1    1    1  
  2    3    4  

  1    1    1  
  3    4    5  

  1    1    1  
  4    5    6  

  1    1    1  
  5    6    7  

REGRO_NEXT_TEST
  REGRO_NEXT generates all restricted growth
  functions.

    1  1  1  1  1  
    2  1  1  1  2  
    3  1  1  2  1  
    4  1  1  2  2  
    5  1  1  2  3  
    6  1  2  1  1  
    7  1  2  1  2  
    8  1  2  1  3  
    9  1  2  2  1  
   10  1  2  2  2  
   11  1  2  2  3  
   12  1  2  3  1  
   13  1  2  3  2  
   14  1  2  3  3  
   15  1  2  3  4  

RFRAC_TO_CFRAC_TEST
  RFRAC_TO_CFRAC: ratio to continued fration.

  Rational polynomial fraction coefficients:

  P:             1           1           2
  Q:             1           3           1           1

  Continued fraction coefficients:
         0             1
         1           0.5
         2       1.33333
         3          -0.5
         4          -1.5
         5             2

  Recovered rational polynomial:

  P:             1           1           2
  Q:             1           3           1           1

RFRAC_TO_JFRAC_TEST
  RFRAC_TO_JFRAC converts a rational polynomial
  fraction to a J fraction.

  The original rational polynomial coefficients:

      0.218418        0.956318        0.829509        0.561695        0.415307       0.0661187  
      0.641848        0.273997        0.109216         1.57976        0.153816         1.12019               1  

  The J fraction coefficients:

     0.0661187         24.0763       -0.310636         1.40276         5.16789      -0.0686133  
      -5.16104         4.91564        -0.94563        -1.04001         2.91888        0.432351  

  The recovered rational polynomial:

      0.218418        0.956318        0.829509        0.561695        0.415307       0.0661187  
      0.641848        0.273997        0.109216         1.57976        0.153816         1.12019               1  

SCHROEDER_TEST
  SCHROEDER computes the Schroeder numbers.

   N    S(N)

     1       1
     2       1
     3       3
     4      11
     5      45
     6     197
     7     903
     8    4279
     9   20793
    10  103049

SORT_HEAP_EXTERNAL_TEST
  SORT_HEAP_EXTERNAL sorts objects externally.

  Before sorting:
       1         5
       2        20
       3        17
       4        12
       5         9
       6         2
       7         6
       8         3
       9         1
      10        13
      11         2
      12         9
      13         9
      14        16
      15        16
      16         1
      17        18
      18         8
      19         2
      20         1

  After sorting:
       1         1
       2         1
       3         1
       4         2
       5         2
       6         2
       7         3
       8         5
       9         6
      10         8
      11         9
      12         9
      13         9
      14        12
      15        13
      16        16
      17        16
      18        17
      19        18
      20        20

SUBSET_BY_SIZE_NEXT_TEST
  SUBSET_BY_SIZE_NEXT generates all subsets of an N set.

   1   1   2   3   4   5  
   2   1   2   3   4  
   3   1   2   3   5  
   4   1   2   4   5  
   5   1   3   4   5  
   6   2   3   4   5  
   7   1   2   3  
   8   1   2   4  
   9   1   2   5  
  10   1   3   4  
  11   1   3   5  
  12   1   4   5  
  13   2   3   4  
  14   2   3   5  
  15   2   4   5  
  16   3   4   5  
  17   1   2  
  18   1   3  
  19   1   4  
  20   1   5  
  21   2   3  
  22   2   4  
  23   2   5  
  24   3   4  
  25   3   5  
  26   4   5  
  27   1  
  28   2  
  29   3  
  30   4  
  31   5  
  32  The empty set

SUBSET_LEX_NEXT_TEST
  SUBSET_LEX_NEXT generates all subsets of an N set.
  The user can impose a restriction on the
  maximum size of the subsets.

  Here, we require the subsets to be no larger
  than NDIM = 3
   1  
   1   2  
   1   2   3  
   1   2   4  
   1   2   5  
   1   3  
   1   3   4  
   1   3   5  
   1   4  
   1   4   5  
   1   5  
   2  
   2   3  
   2   3   4  
   2   3   5  
   2   4  
   2   4   5  
   2   5  
   3  
   3   4  
   3   4   5  
   3   5  
   4  
   4   5  
   5  
  The empty set.

SUBSET_GRAY_NEXT_TEST
  SUBSET_GRAY_NEXT generates all subsets of an N set
  using the Gray code ordering:
  0 0 1 0 1 means the subset contains 3 and 5.

  Gray code

   1     0 0 0 0 0
   2     1 0 0 0 0
   3     1 1 0 0 0
   4     0 1 0 0 0
   5     0 1 1 0 0
   6     1 1 1 0 0
   7     1 0 1 0 0
   8     0 0 1 0 0
   9     0 0 1 1 0
  10     1 0 1 1 0
  11     1 1 1 1 0
  12     0 1 1 1 0
  13     0 1 0 1 0
  14     1 1 0 1 0
  15     1 0 0 1 0
  16     0 0 0 1 0
  17     0 0 0 1 1
  18     1 0 0 1 1
  19     1 1 0 1 1
  20     0 1 0 1 1
  21     0 1 1 1 1
  22     1 1 1 1 1
  23     1 0 1 1 1
  24     0 0 1 1 1
  25     0 0 1 0 1
  26     1 0 1 0 1
  27     1 1 1 0 1
  28     0 1 1 0 1
  29     0 1 0 0 1
  30     1 1 0 0 1
  31     1 0 0 0 1
  32     0 0 0 0 1

SUBSET_RANDOM_TEST
  SUBSET_RANDOM picks a subset at random.
  The number of elements in the main set is 5

   1     0 1 1 1 0
   2     0 0 0 0 1
   3     0 0 0 1 1
   4     0 1 0 0 0
   5     1 1 0 0 0

SUBSET_GRAY_RANK_TEST
  SUBSET_GRAY_RANK returns rank of a subset of an N set
  using the Gray code ordering.

  For N = 5, the subset is:
  1 0 1 1 0 

  The rank is 28

SUBSET_GRAY_UNRANK_TEST
  SUBSET_GRAY_UNRANK finds the subset of an N set
  of a given rank under the Gray code ordering.

  N is 5

  Rank   Subset

     1   0 0 0 0 0
     2   0 0 0 0 1
     3   0 0 0 1 1
     4   0 0 0 1 0
     5   0 0 1 1 0
     6   0 0 1 1 1
     7   0 0 1 0 1
     8   0 0 1 0 0
     9   0 1 1 0 0
    10   0 1 1 0 1

SUBCOMP_NEXT_TEST
  SUBCOMP_NEXT generates subcompositions.

  Seek all subcompositions of N = 6
  using K = 3 parts.

     #   Sum

     1     0     0   0   0
     2     1     1   0   0
     3     1     0   1   0
     4     1     0   0   1
     5     2     2   0   0
     6     2     1   1   0
     7     2     0   2   0
     8     2     1   0   1
     9     2     0   1   1
    10     2     0   0   2
    11     3     3   0   0
    12     3     2   1   0
    13     3     1   2   0
    14     3     0   3   0
    15     3     2   0   1
    16     3     1   1   1
    17     3     0   2   1
    18     3     1   0   2
    19     3     0   1   2
    20     3     0   0   3
    21     4     4   0   0
    22     4     3   1   0
    23     4     2   2   0
    24     4     1   3   0
    25     4     0   4   0
    26     4     3   0   1
    27     4     2   1   1
    28     4     1   2   1
    29     4     0   3   1
    30     4     2   0   2
    31     4     1   1   2
    32     4     0   2   2
    33     4     1   0   3
    34     4     0   1   3
    35     4     0   0   4
    36     5     5   0   0
    37     5     4   1   0
    38     5     3   2   0
    39     5     2   3   0
    40     5     1   4   0
    41     5     0   5   0
    42     5     4   0   1
    43     5     3   1   1
    44     5     2   2   1
    45     5     1   3   1
    46     5     0   4   1
    47     5     3   0   2
    48     5     2   1   2
    49     5     1   2   2
    50     5     0   3   2
    51     5     2   0   3
    52     5     1   1   3
    53     5     0   2   3
    54     5     1   0   4
    55     5     0   1   4
    56     5     0   0   5
    57     6     6   0   0
    58     6     5   1   0
    59     6     4   2   0
    60     6     3   3   0
    61     6     2   4   0
    62     6     1   5   0
    63     6     0   6   0
    64     6     5   0   1
    65     6     4   1   1
    66     6     3   2   1
    67     6     2   3   1
    68     6     1   4   1
    69     6     0   5   1
    70     6     4   0   2
    71     6     3   1   2
    72     6     2   2   2
    73     6     1   3   2
    74     6     0   4   2
    75     6     3   0   3
    76     6     2   1   3
    77     6     1   2   3
    78     6     0   3   3
    79     6     2   0   4
    80     6     1   1   4
    81     6     0   2   4
    82     6     1   0   5
    83     6     0   1   5
    84     6     0   0   6

SUBCOMPNZ_NEXT_TEST
  SUBCOMPNZ_NEXT generates subcompositions using nonzero parts.

  Seek all subcompositions of N = 6
  using K = 3 nonzero parts.

     #   Sum

     1     3     1   1   1
     2     4     2   1   1
     3     4     1   2   1
     4     4     1   1   2
     5     5     3   1   1
     6     5     2   2   1
     7     5     1   3   1
     8     5     2   1   2
     9     5     1   2   2
    10     5     1   1   3
    11     6     4   1   1
    12     6     3   2   1
    13     6     2   3   1
    14     6     1   4   1
    15     6     3   1   2
    16     6     2   2   2
    17     6     1   3   2
    18     6     2   1   3
    19     6     1   2   3
    20     6     1   1   4

SUBCOMPNZ2_NEXT_TEST
  SUBCOMPNZ2_NEXT generates subcompositions using nonzero parts.

  Seek all subcompositions of N
  using K = 3 nonzero parts.

  Here N is in the range 5 <= N <= 7

     #     N

     1     5     3   1   1
     2     5     2   2   1
     3     5     1   3   1
     4     5     2   1   2
     5     5     1   2   2
     6     5     1   1   3
     7     6     4   1   1
     8     6     3   2   1
     9     6     2   3   1
    10     6     1   4   1
    11     6     3   1   2
    12     6     2   2   2
    13     6     1   3   2
    14     6     2   1   3
    15     6     1   2   3
    16     6     1   1   4
    17     7     5   1   1
    18     7     4   2   1
    19     7     3   3   1
    20     7     2   4   1
    21     7     1   5   1
    22     7     4   1   2
    23     7     3   2   2
    24     7     2   3   2
    25     7     1   4   2
    26     7     3   1   3
    27     7     2   2   3
    28     7     1   3   3
    29     7     2   1   4
    30     7     1   2   4
    31     7     1   1   5

SUBTRIANGLE_NEXT_TEST
  SUBTRIANGLE_NEXT generates the indices of subtriangles
  in a triangle whose edges were divided into N subedges.

  For this test, N = 4

  Rank    I1  J1    I2  J2    I3  J3

     1     0   0     1   0     0   1
     2     1   1     0   1     1   0
     3     1   0     2   0     1   1
     4     2   1     1   1     2   0
     5     2   0     3   0     2   1
     6     3   1     2   1     3   0
     7     3   0     4   0     3   1
     8     0   1     1   1     0   2
     9     1   2     0   2     1   1
    10     1   1     2   1     1   2
    11     2   2     1   2     2   1
    12     2   1     3   1     2   2
    13     0   2     1   2     0   3
    14     1   3     0   3     1   2
    15     1   2     2   2     1   3
    16     0   3     1   3     0   4

THUE_BINARY_NEXT_TEST
  THUE_BINARY_NEXT returns the next
  Thue binary sequence.

   1    0
   2    01
   4    0110
   8    01101001
  16    0110100110010110
  32    01101001100101101001011001101001
  64    0110100110010110100101100110100110010110011010010110100110010110

THUE_TERNARY_NEXT_TEST
  THUE_TERNARY_NEXT returns the next
  Thue ternary sequence.

   1    1
   3    102
   6    102120
  12    102120102012
  24    102120102012102120121020
  48    102120102012102120121020102120102012102010212012

TRIANG_TEST
  TRIANG relabels elements for a partial ordering,

  The input matrix:

  Col:          1             2             3             4             5             6             7             8             9            10       
  Row
  ---
    1       1       0       0       0       0       0       0       0       0       0  
    2       0       1       0       1       0       1       0       1       0       0  
    3       1       0       1       1       0       0       0       0       0       0  
    4       0       0       0       1       0       0       0       0       0       0  
    5       1       1       1       1       1       1       1       1       0       1  
    6       0       0       0       1       0       1       0       1       0       0  
    7       1       0       1       1       0       1       1       1       0       1  
    8       0       0       0       1       0       0       0       1       0       0  
    9       0       0       0       0       0       0       0       0       0       0  
   10       1       0       1       1       0       0       0       1       0       1  

  The new ordering:

     0   1   2   3   4   5   6   7   8   9
     4   5   3   8   0   6   1   7   9   2

  The reordered matrix:

  Col:          1             2             3             4             5             6             7             8             9            10       
  Row
  ---
    1       1       1       1       1       1       1       1       1       1       0  
    2       0       1       1       1       1       0       1       1       1       0  
    3       0       0       1       1       1       0       0       1       1       0  
    4       0       0       0       1       1       0       0       0       1       0  
    5       0       0       0       0       1       0       0       0       0       0  
    6       0       0       0       0       0       1       1       1       1       0  
    7       0       0       0       0       0       0       1       1       1       0  
    8       0       0       0       0       0       0       0       1       1       0  
    9       0       0       0       0       0       0       0       0       1       0  
   10       0       0       0       0       0       0       0       0       0       0  

TUPLE_NEXT_TEST
  TUPLE_NEXT returns the next "tuple", that is,
  a vector of N integers, each between M1 and M2.

  M1 = 2
  M2 = 4
  N = 2

   1   2     2  
   2   2     3  
   3   2     4  
   4   3     2  
   5   3     3  
   6   3     4  
   7   4     2  
   8   4     3  
   9   4     4  

TUPLE_NEXT_FAST_TEST
  TUPLE_NEXT_FAST returns the next "tuple", that is,
  a vector of N integers, each between 1 and M.

  M = 3
  N = 2

   0   1     1  
   1   1     2  
   2   1     3  
   3   2     1  
   4   2     2  
   5   2     3  
   6   3     1  
   7   3     2  
   8   3     3  

TUPLE_NEXT_GE_TEST
  TUPLE_NEXT_GE returns the next nondecreasting "tuple",
  that is, a vector of N integers, each between 1 and M,
  with the additional property that the digits never decrease
  reading from left to right.

  M = 3
  N = 3

   1   1     1     1  
   2   1     1     2  
   3   1     1     3  
   4   1     2     2  
   5   1     2     3  
   6   1     3     3  
   7   2     2     2  
   8   2     2     3  
   9   2     3     3  
  10   3     3     3  

TUPLE_NEXT2_TEST
  TUPLE_NEXT2 returns the next "tuple",
  that is, a vector of N integers.
  Each position in the vector has a separate min and max.
  reading from left to right.

  N = 3


  The minimum values:
       1         2
       2         3
       3         8

  The maximum values:
       1         4
       2         3
       3         5


   1   2     3     8  
   2   2     3     7  
   3   2     3     6  
   4   2     3     5  
   5   3     3     8  
   6   3     3     7  
   7   3     3     6  
   8   3     3     5  
   9   4     3     8  
  10   4     3     7  
  11   4     3     6  
  12   4     3     5  

UBVEC_ADD_TEST
  UBVEC_ADD adds unsigned binary vectors 
  representing unsigned integers;

        I        J        K = I + J


        22        96
  Directly:                118
 UBVEC_ADD                 118

        83        56
  Directly:                139
 UBVEC_ADD                 139

        41         6
  Directly:                 47
 UBVEC_ADD                  47

        26        11
  Directly:                 37
 UBVEC_ADD                  37

         4        64
  Directly:                 68
 UBVEC_ADD                  68

         6        45
  Directly:                 51
 UBVEC_ADD                  51

        40        76
  Directly:                116
 UBVEC_ADD                 116

        80         0
  Directly:                 80
 UBVEC_ADD                  80

        90        35
  Directly:                125
 UBVEC_ADD                 125

         9         1
  Directly:                 10
 UBVEC_ADD                  10

UBVEC_PRINT_TEST
  UBVEC_PRINT prints an unsigned binary vector.

  UBVEC:
  1001011100

UBVEC_TO_UI4_TEST
  UBVEC_TO_UI4 converts an unsigned binary vector
  to an unsigned integer;

  I --> BVEC  -->  I

  0  0000000000    0
  1  0000000001    1
  2  0000000010    2
  3  0000000011    3
  4  0000000100    4
  5  0000000101    5
  6  0000000110    6
  7  0000000111    7
  8  0000001000    8
  9  0000001001    9
 10  0000001010   10

UBVEC_XOR_TEST
  UBVEC_XOR exclusive-ors unsigned binary vectors 
  representing unsigned integers;

        I        J        K = I XOR J

        22        96       118
        83        56       107
        41         6        47
        26        11        17
         4        64        68
         6        45        43
        40        76       100
        80         0        80
        90        35       121
         9         1         8

UI4_TO_UBVEC_TEST
  UI4_TO_UBVEC converts an unsigned integer to an 
  unsigned binary vector;

  I --> BVEC  -->  I

  0  0000000000    0
  1  0000000001    1
  2  0000000010    2
  3  0000000011    3
  4  0000000100    4
  5  0000000101    5
  6  0000000110    6
  7  0000000111    7
  8  0000001000    8
  9  0000001001    9
 10  0000001010   10

VEC_COLEX_NEXT_TEST
  VEC_COLEX_NEXT generates all DIM_NUM-vectors
  in colex order in a given base BASE.

  The spatial dimension DIM_NUM = 3
  The base BASE =                 3

   0     0     0  
   1     0     0  
   2     0     0  
   0     1     0  
   1     1     0  
   2     1     0  
   0     2     0  
   1     2     0  
   2     2     0  
   0     0     1  
   1     0     1  
   2     0     1  
   0     1     1  
   1     1     1  
   2     1     1  
   0     2     1  
   1     2     1  
   2     2     1  
   0     0     2  
   1     0     2  
   2     0     2  
   0     1     2  
   1     1     2  
   2     1     2  
   0     2     2  
   1     2     2  
   2     2     2  

VEC_COLEX_NEXT2_TEST
  VEC_COLEX_NEXT2 generates all DIM_NUM-vectors
  in colex order in a given base BASE.

  The spatial dimension DIM_NUM = 3

  The base vector:

   2     1     3  

   0     0     0  
   1     0     0  
   0     0     1  
   1     0     1  
   0     0     2  
   1     0     2  

VEC_COLEX_NEXT3_TEST
  VEC_COLEX_NEXT3 generates all DIM_NUM-vectors
  in colex order in a given base BASE.

  The spatial dimension DIM_NUM = 3

  The base vector:

   2     1     3  

   1     1     1  
   2     1     1  
   1     1     2  
   2     1     2  
   1     1     3  
   2     1     3  

VEC_GRAY_NEXT_TEST
  VEC_GRAY_NEXT generates product space elements.

  The number of components is 4
  The number of elements is 16
  Each component has its own number of degrees of
  freedom.

  Rank Change        2     2     1     4  

   1   0   0     0     0     0  
   2   3   0     0     0     1  
   3   3   0     0     0     2  
   4   3   0     0     0     3  
   5   1   0     1     0     3  
   6   3   0     1     0     2  
   7   3   0     1     0     1  
   8   3   0     1     0     0  
   9   0   1     1     0     0  
  10   3   1     1     0     1  
  11   3   1     1     0     2  
  12   3   1     1     0     3  
  13   1   1     0     0     3  
  14   3   1     0     0     2  
  15   3   1     0     0     1  
  16   3   1     0     0     0  

VEC_GRAY_RANK_TEST
  VEC_GRAY_RANK ranks product space elements.

  The number of components is 4
  The number of elements is 16
  Each component has its own number of degrees of
  freedom, which, for this example, are:

  VEC_GRAY_RANK reports the element

   1     1     0     2  

  has rank 11

VEC_GRAY_UNRANK_TEST
  VEC_GRAY_UNRANK unranks product space elements.

  The number of components is 4
  The number of elements is 16

  VEC_GRAY_UNRANK reports the element of rank 7  is:

   0     1     0     1  

VEC_LEX_NEXT_TEST
  VEC_LEX_NEXT generates all DIM_NUM-vectors
  in a given base.  Here we use base 3

   0     0     0  
   0     0     1  
   0     0     2  
   0     1     0  
   0     1     1  
   0     1     2  
   0     2     0  
   0     2     1  
   0     2     2  
   1     0     0  
   1     0     1  
   1     0     2  
   1     1     0  
   1     1     1  
   1     1     2  
   1     2     0  
   1     2     1  
   1     2     2  
   2     0     0  
   2     0     1  
   2     0     2  
   2     1     0  
   2     1     1  
   2     1     2  
   2     2     0  
   2     2     1  
   2     2     2  

VEC_RANDOM_TEST
  VEC_RANDOM generates a random N-vector
  in a given base.
  Here, we use base 3

   1       0     2     2  
   2       1     1     0  
   3       0     0     0  
   4       1     0     1  
   5       1     2     2  

VECTOR_CONSTRAINED_NEXT_TEST
  VECTOR_CONSTRAINED_NEXT:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    P = Product X_MAX(1:N)
  Accept only vectors for which:
    sum ( (X(1:N)-1) * P / X_MAX(1:N) ) <= P

  X_MIN:
     2     2     1

  X_MAX:
     4     5     3

  Maximum allowed CONSTRAINT = P = 60

         1            27         2         2         1
         2            42         3         2         1
         3            57         4         2         1
         4            39         2         3         1
         5            54         3         3         1
         6            51         2         4         1
         7            47         2         2         2
         8            59         2         3         2

VECTOR_CONSTRAINED_NEXT2_TEST
  VECTOR_CONSTRAINED_NEXT2:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    P = Product X_MAX(1:N)
  Accept only vectors for which:
    sum ( X(1:N) * P / X_MAX(1:N) ) <= P

  X_MIN:
     1     1

  X_MAX:
     5     6

  Maximum allowed CONSTRAINT = P = 30

         1            11         1         1
         2            17         2         1
         3            23         3         1
         4            29         4         1
         5            16         1         2
         6            22         2         2
         7            28         3         2
         8            21         1         3
         9            27         2         3
        10            26         1         4

  X_MIN:
     1     1     1

  X_MAX:
     5     6     4

  Maximum allowed CONSTRAINT = P = 120

         1            74         1         1         1
         2            98         2         1         1
         3            94         1         2         1
         4           118         2         2         1
         5           114         1         3         1
         6           104         1         1         2

VECTOR_CONSTRAINED_NEXT3_TEST
  VECTOR_CONSTRAINED_NEXT3:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    CONSTRAINT = sum ( X(1:N) / X_MAX(1:N) )
  Accept only vectors for which:
    CONSTRAINT <= 1

  X_MIN:
     1     1

  X_MAX:
     5     6

         1        0.366667         1         1
         2        0.566667         2         1
         3        0.766667         3         1
         4        0.966667         4         1
         5        0.533333         1         2
         6        0.733333         2         2
         7        0.933333         3         2
         8             0.7         1         3
         9             0.9         2         3
        10        0.866667         1         4

  X_MIN:
     1     1     1

  X_MAX:
     5     6     4

         1        0.616667         1         1         1
         2        0.816667         2         1         1
         3        0.783333         1         2         1
         4        0.983333         2         2         1
         5            0.95         1         3         1
         6        0.866667         1         1         2

VECTOR_CONSTRAINED_NEXT4_TEST
  VECTOR_CONSTRAINED_NEXT4:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    TOTAL <= Q

  ALPHA:         4         3
  Q:            20
  X_MIN:     1     0
  X_MAX:     2     6

         1               4         1         0
         2               8         2         0
         3               7         1         1
         4              11         2         1
         5              10         1         2
         6              14         2         2
         7              13         1         3
         8              17         2         3
         9              16         1         4
        10              20         2         4
        11              19         1         5

  ALPHA:         4         3         5
  Q:            20
  X_MIN:     1     0     1
  X_MAX:     2     6     4

         1               9         1         0         1
         2              13         2         0         1
         3              12         1         1         1
         4              16         2         1         1
         5              15         1         2         1
         6              19         2         2         1
         7              18         1         3         1
         8              14         1         0         2
         9              18         2         0         2
        10              17         1         1         2
        11              20         1         2         2
        12              19         1         0         3

VECTOR_CONSTRAINED_NEXT5_TEST
  VECTOR_CONSTRAINED_NEXT5:
  Generate integer vectors X such that:
    SUM_MIN <= sum ( X(1:N) ) <= SUM_MAX,
  We require every X(I) to be at least 1.

  N =       3
  SUM_MIN = 5
  SUM_MAX = 7

         #        X(1)      X(2)      X(3)

         1         3         1         1
         2         2         2         1
         3         2         1         2
         4         1         3         1
         5         1         2         2
         6         1         1         3
         7         4         1         1
         8         3         2         1
         9         3         1         2
        10         2         3         1
        11         2         2         2
        12         2         1         3
        13         1         4         1
        14         1         3         2
        15         1         2         3
        16         1         1         4
        17         5         1         1
        18         4         2         1
        19         4         1         2
        20         3         3         1
        21         3         2         2
        22         3         1         3
        23         2         4         1
        24         2         3         2
        25         2         2         3
        26         2         1         4
        27         1         5         1
        28         1         4         2
        29         1         3         3
        30         1         2         4
        31         1         1         5

VECTOR_CONSTRAINED_NEXT6_TEST
  VECTOR_CONSTRAINED_NEXT6:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    Q_MIN <= TOTAL <= Q_MAX

  ALPHA:         4         3
  Q_MIN:        16
  Q_MAX:        20
  X_MIN:     1     0
  X_MAX:     2     6

         1              16         1         4
         2              19         1         5
         3              17         2         3
         4              20         2         4

  ALPHA:         4         3         5
  Q_MIN:        16
  Q_MAX:        20
  X_MIN:     1     0     1
  X_MAX:     2     6     4

         1              19         1         0         3
         2              17         1         1         2
         3              20         1         2         2
         4              18         1         3         1
         5              18         2         0         2
         6              16         2         1         1
         7              19         2         2         1

VECTOR_CONSTRAINED_NEXT7_TEST
  VECTOR_CONSTRAINED_NEXT7:
  Consider vectors:
    0 <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    Q_MIN <= TOTAL <= Q_MAX

  ALPHA:         4         3
  Q_MIN:        16
  Q_MAX:        20
  X_MAX:     2     6

         1              18         0         6
         2              19         1         5
         3              17         2         3
         4              20         2         4

  ALPHA:         4         3         5
  Q_MIN:        16
  Q_MAX:        20
  X_MAX:     2     6     4

         1              20         0         0         4
         2              18         0         1         3
         3              19         0         3         2
         4              17         0         4         1
         5              20         0         5         1
         6              18         0         6         0
         7              19         1         0         3
         8              17         1         1         2
         9              20         1         2         2
        10              18         1         3         1
        11              19         1         5         0
        12              18         2         0         2
        13              19         2         2         1
        14              17         2         3         0
        15              20         2         4         0

VECTOR_NEXT_TEST
  VECTOR_NEXT:
  Generate all vectors X such that:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),

    X_MIN:         1         4
         1         1         4
         2         2         4
         3         1         5
         4         2         5
         5         1         6
         6         2         6
    X_MAX:         2         6

    X_MIN:         1         4         3
         1         1         4         3
         2         2         4         3
         3         1         5         3
         4         2         5         3
         5         1         6         3
         6         2         6         3
         7         1         4         4
         8         2         4         4
         9         1         5         4
        10         2         5         4
        11         1         6         4
        12         2         6         4
    X_MAX:         2         6         4

YTB_ENUM_TEST
  YTB_ENUM counts Young tableau.

   N  YTB_ENUM(N)

   0           0
   1           1
   2           2
   3           4
   4          10
   5          26
   6          76
   7         232
   8         764
   9        2620
  10        9496

YTB_NEXT_TEST
  YTB_NEXT generates Young tableaus.


 
     1       4       6  
     2       5  
     3  

 
     1       3       6  
     2       5  
     4  

 
     1       2       6  
     3       5  
     4  

 
     1       3       6  
     2       4  
     5  

 
     1       2       6  
     3       4  
     5  

 
     1       4       5  
     2       6  
     3  

 
     1       3       5  
     2       6  
     4  

 
     1       2       5  
     3       6  
     4  

 
     1       3       4  
     2       6  
     5  

 
     1       2       4  
     3       6  
     5  

 
     1       2       3  
     4       6  
     5  

 
     1       3       5  
     2       4  
     6  

 
     1       2       5  
     3       4  
     6  

 
     1       3       4  
     2       5  
     6  

 
     1       2       4  
     3       5  
     6  

 
     1       2       3  
     4       5  
     6  

YTB_RANDOM_TEST
  YTB_RANDOM generates a random Young tableau

 
     1       2       6  
     3       5  
     4  

 
     1       3       6  
     2       4  
     5  

 
     1       3       6  
     2       4  
     5  

 
     1       3       5  
     2       4  
     6  

 
     1       2       5  
     3       4  
     6  

SUBSET_PRB
  Normal end of execution.

04 July 2016 08:34:28 AM
